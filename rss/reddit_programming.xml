<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sun, 22 Feb 2026 09:38:08 GMT</lastBuildDate>
    <item>
      <title>你没有被抛在后面</title>
      <link>https://www.reddit.com/r/programming/comments/1rbhfvz/you_are_not_left_behind/</link>
      <description><![CDATA[在当前法学硕士和法学硕士的背景下，对新软件开发工具不断发展成熟的看法很好。  结论：在决定更广泛采用和推广之前，等待并让工具真正成熟（如果会的话，情况并不总是如此）通常是更明智的做法。大量的时间和精力投入。   由   提交/u/BinaryIgor  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbhfvz/you_are_not_left_behind/</guid>
      <pubDate>Sun, 22 Feb 2026 09:22:49 GMT</pubDate>
    </item>
    <item>
      <title>Linux 7.0 为 Rust 1.95 做准备</title>
      <link>https://www.reddit.com/r/programming/comments/1rbgk2f/linux_70_makes_preparations_for_rust_195/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbgk2f/linux_70_makes_preparations_for_rust_195/</guid>
      <pubDate>Sun, 22 Feb 2026 08:28:56 GMT</pubDate>
    </item>
    <item>
      <title>终端实际上​​如何运行程序。</title>
      <link>https://www.reddit.com/r/programming/comments/1rbg158/how_a_terminal_actually_runs_programs/</link>
      <description><![CDATA[ 由   提交/u/Sushant098123  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbg158/how_a_terminal_actually_runs_programs/</guid>
      <pubDate>Sun, 22 Feb 2026 07:57:15 GMT</pubDate>
    </item>
    <item>
      <title>我为 1 个用户（我）构建了一个具有端到端加密的企业级应用程序 - 然后意识到移动优先消除了整个问题</title>
      <link>https://www.reddit.com/r/programming/comments/1rbfz5b/i_built_an_enterprisegrade_app_with_e2e/</link>
      <description><![CDATA[我是一名后端/基础设施工程师，多年来我一直以构建生产系统的方式构建个人工具。上周，我构建了一个预算跟踪器，其中包括端到端加密、DDD 架构、完整单元和 E2E 测试、通过 GitHub Actions、Postgres、Hetzner 托管、监控进行的 CI/CD... 然后在 Docker 构建过程中我愣住了：为什么我需要企业基础设施来构建一个仅我使用的应用程序？ 简单的个人应用程序的非功能性要求是疯狂的：安全性、身份验证、监控、CI/CD、服务器管理、数据库管理。功能（实际价值）受到的关注最少。 因此，我使用 Claude Code 将所有内容迁移到 iOS 移动应用程序。现在：SQLite 代替 Postgres，FaceID 代替自定义身份验证，无需破解服务器，无需管理基础设施。 100% 专注于功能。 更重要的是——自 2018 年 Android 以来我就没有做过移动开发，也不了解 Swift。无论如何，Vibe 编码使之成为可能。 包含图表和详细信息的博客文章：https://www.vitaliihonchar.com/insights/what-changed-in-the-personal-application-development-in-the-vibe-coding-era 还有其他人发现自己出于职业习惯而过度设计个人项目吗？   由   提交 /u/Historical_Wing_9573   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbfz5b/i_built_an_enterprisegrade_app_with_e2e/</guid>
      <pubDate>Sun, 22 Feb 2026 07:53:54 GMT</pubDate>
    </item>
    <item>
      <title>技术事后剖析：将加密验证直接嵌入到 Rust 编译器管道中的架构摩擦</title>
      <link>https://www.reddit.com/r/programming/comments/1rbe7fr/technical_postmortem_the_architectural_friction/</link>
      <description><![CDATA[我刚刚花了两周时间从头开始编写一个编译器（Ark-Lang，Rust 中的 ~21k LOC），我想写一篇关于我遇到的最困难的架构摩擦点的文章：将 SOC-2 级加密验证直接嵌入到 AST 解析阶段。 通常，编译器是黑匣子。你给他们提供源代码，他们会吐出字节码或 WASM。我希望编译器能够在物理上证明它在没有外部 linter 的情况下完成了工作。  工程挑战： 我必须构建一个 5 阶段管道，其中 AST 实际上在 Lexer/Parser 完成后立即进行 Merkle 哈希处理。   词法分析/解析 AST Merkle-root 哈希 线性类型检查（跟踪资源消耗以防止双花） Codegen（针对自定义堆栈虚拟机和本机 WASM） 生成 HMAC 签名ProofBundle。  这里的绝对噩梦是保持线性类型检查器与 WASM 内存偏移同步，同时确保 AST 哈希在优化过程中不会发生变化。我基本上必须冻结 AST 状态，对其进行哈希处理，然后将不可变的引用传递给线性检查器（“checker.rs”）。  凌晨 4 点手动编写 WASM 代码生成器可能是一个错误，但现在可以干净地编译了。  还有其他人尝试过在编译器级别生成加密收据吗？好奇其他人如何在多遍优化期间处理 AST 冻结。    由   提交/u/AbrocomaAny8436  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbe7fr/technical_postmortem_the_architectural_friction/</guid>
      <pubDate>Sun, 22 Feb 2026 06:10:35 GMT</pubDate>
    </item>
    <item>
      <title>亲爱的人工智能，不错的尝试。现在我们来谈谈生产。</title>
      <link>https://www.reddit.com/r/programming/comments/1rbc23l/nice_try_dear_ai_now_lets_talk_about_production/</link>
      <description><![CDATA[最近我想编写一个将目录上传到 S3 的脚本。我决定使用副驾驶。我已经使用它有一段时间了。本文试图证明两件事：(a) 人工智能（仍然）无法取代我作为高级软件工程师；(b) 学习编程并专注于基础知识仍然有意义。   由   提交/u/krasimirtsonev   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbc23l/nice_try_dear_ai_now_lets_talk_about_production/</guid>
      <pubDate>Sun, 22 Feb 2026 04:15:33 GMT</pubDate>
    </item>
    <item>
      <title>零 GC 和 78M 样本/秒：将 Node.js 22 推向有状态 DSP 的极限</title>
      <link>https://www.reddit.com/r/programming/comments/1rbbvh2/zerogc_and_78m_samplessec_pushing_nodejs_22_to/</link>
      <description><![CDATA[我一直在对 Node.js (dspx) 的硬件感知信号处理库进行基准测试，发现使用正确的架构，您可以有效地绕过 V8 垃圾收集器。通过实施零复制管道，我成功地在 AWS Lambda（1769MB RAM）上的单个 vCPU 上实现了每秒 7800 万个样本。更有趣的是内存配置文件：在输入大小介于 212 和 220 之间时，系统显示零或负堆增长，从而导致确定性 p99 延迟即使在重负载下也能保持平稳。 我还专注于微秒级状态序列化，以使有状态函数（如卡尔曼滤波器）在 Lambda 等临时运行时上可行。部署大小仅为 1.3MB，使冷启动时间始终保持在 170 毫秒到 240 毫秒之间。它包括从 MFCC 和 Mel-Spectrograms 到自适应滤波器和 ICA/PCA 转换的完整工具包。 默认情况下，它在 C++ 和 JavaScript 端都是单线程的，因此用户可以使用工作线程、原子和 SharedArrayBuffers 在 JavaScript 中对其进行多线程处理。 基准存储库：https://github.com/A-KGeorge/dspx-benchmark 代码存储库：https://github.com/A-KGeorge/dspx   由   提交/u/sarcasm4052  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbbvh2/zerogc_and_78m_samplessec_pushing_nodejs_22_to/</guid>
      <pubDate>Sun, 22 Feb 2026 04:06:14 GMT</pubDate>
    </item>
    <item>
      <title>Rust 不可能拥有理智的 HKT</title>
      <link>https://www.reddit.com/r/programming/comments/1rbai5s/its_impossible_for_rust_to_have_sane_hkt/</link>
      <description><![CDATA[众所周知，Rust 找不到支持 HKT 的好方法。这并不是一个缺乏努力的问题。这是由一个基本缺陷引起的，Rust 在与业务逻辑相同的级别和位置上具体化了技术命题。当它们都是类型级别的一等公民并且无法区分时，事情就会开始崩溃。   由   提交/u/vspefs  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbai5s/its_impossible_for_rust_to_have_sane_hkt/</guid>
      <pubDate>Sun, 22 Feb 2026 02:57:52 GMT</pubDate>
    </item>
    <item>
      <title>AI 不应该编写 Python 或 C。如果人类不再编写代码，编程语言应该发展为机器思考的方式……而不是人类。</title>
      <link>https://www.reddit.com/r/programming/comments/1rbafjv/ai_should_not_write_python_or_c_if_humans_will_no/</link>
      <description><![CDATA[我认为讨论应该超越“程序员替换”的问题。 让我们假设今天人工智能编写的代码量是一个轨迹而不是一个假设。  让我们假设人工智能将取代人类程序员，在大多数（如果不是全部）编程职位上。  现在的问题应该演变为编程语言本身。因为如果这就是未来，那么我们就会用受人类需求限制的编程语言来阻止它。  为什么AI需要写Python？或者任何其他适合人类的语言？ 程序员编写的内容中大约 97% 不是计算。它是与机器和其他可能读取其代码的人类之间的通信。 当代码不再需要由人类程序员读取时 -   不需要有意义的变量和函数名称 不需要空格、格式、样板文件、导入、类声明、构造函数、getter、setter、注释、文档 将不再有语法错误 没有软件堆栈  代码的效率提高了 20 倍 - 50 倍，而人类仍然需要处理“什么”问题。而不是“如何”。  很明显，那些能够最好地阐明软件（而不是其代码）的意图和规范，并有助于缩小上述意图不一致差距的人，将成为未来需求量很大的社交计算艺术家。 我已经就此写了一篇详细的文章，因为我相信这是下一个需要讨论的发展领域。    由   提交/u/SillAlive-Act3  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rbafjv/ai_should_not_write_python_or_c_if_humans_will_no/</guid>
      <pubDate>Sun, 22 Feb 2026 02:54:22 GMT</pubDate>
    </item>
    <item>
      <title>JavaScript 和 Python 中循环反模式的基准测试：V8 为您处理什么以及不处理什么</title>
      <link>https://www.reddit.com/r/programming/comments/1rb7vdo/benchmarking_loop_antipatterns_in_javascript_and/</link>
      <description><![CDATA[最让我惊讶的发现：正则表达式提升提供了 1.03 倍的加速——本底噪声。 V8 在内部缓存编译的正则表达式，因此自己提升它在 JS 中没有任何作用。 filter().map() 与 reduce() (0.99×) 相同。 真正重要的两个：嵌套循环 → Map 查找 (64×) 和循环内的 JSON.parse (46×)。两者都能够在 JIT 中幸存下来，因为一个会改变算法复杂性，另一个会在每次迭代时强制进行新的堆分配。 还使用 Babel/AST 检测器扫描了 webpack、 Three.js、Vite、lodash、Airflow、Django 和其他文件中的 59,728 个文件。存储库中的完整数据和源代码。   由   提交 /u/StackInsightDev   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rb7vdo/benchmarking_loop_antipatterns_in_javascript_and/</guid>
      <pubDate>Sun, 22 Feb 2026 00:54:00 GMT</pubDate>
    </item>
    <item>
      <title>使用自动终止开关构建 Cloudflare Workers 使用情况监视器</title>
      <link>https://www.reddit.com/r/programming/comments/1rb5t8k/building_a_cloudflare_workers_usage_monitor_with/</link>
      <description><![CDATA[ 由   提交 /u/PizzaConsole   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rb5t8k/building_a_cloudflare_workers_usage_monitor_with/</guid>
      <pubDate>Sat, 21 Feb 2026 23:22:55 GMT</pubDate>
    </item>
    <item>
      <title>回到 FreeBSD：第 1 部分（从 Unix chroot 到 FreeBSD Jails 和 Docker）</title>
      <link>https://www.reddit.com/r/programming/comments/1rb5k68/back_to_freebsd_part_1_from_unix_chroot_to/</link>
      <description><![CDATA[ 由   提交/u/imbev   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rb5k68/back_to_freebsd_part_1_from_unix_chroot_to/</guid>
      <pubDate>Sat, 21 Feb 2026 23:12:17 GMT</pubDate>
    </item>
    <item>
      <title>为什么有人应该关心低级编程？</title>
      <link>https://www.reddit.com/r/programming/comments/1rb1lr2/why_should_anyone_care_about_lowlevel_programming/</link>
      <description><![CDATA[有人对这篇文章有什么意见吗？   由   提交/u/No_Good7445   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rb1lr2/why_should_anyone_care_about_lowlevel_programming/</guid>
      <pubDate>Sat, 21 Feb 2026 20:28:32 GMT</pubDate>
    </item>
    <item>
      <title>你会忽略 django 查询中的重音单词吗</title>
      <link>https://www.reddit.com/r/programming/comments/1rauh1u/do_you_ignore_accented_words_in_your_django_query/</link>
      <description><![CDATA[您知道吗，对“Helen”的正常搜索需要搜索“Helen”。通常会错过像“Hélène”这样的名字吗？默认情况下，icontains 仅匹配精确的字符，因此重音符号或变音符号可能会让用户感觉搜索不完整。在 PostgreSQL 上，使用 unaccent 查找可以修复此问题： Author.objects.filter(nameunaccenticontains=“Helen”) 现在，您的搜索会找到“Helen”、“Helena”和“Hélène”，使您的应用程序真正具有国际友好性。不要忘记包含“django.contrib.postgres”在您安装的应用程序中，并在 django 迁移中启用 UnaccentExtension 或使用 SQL (CREATE EXTENSION &quot;unaccent&quot;;)   由   提交 /u/natanasrat   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rauh1u/do_you_ignore_accented_words_in_your_django_query/</guid>
      <pubDate>Sat, 21 Feb 2026 15:50:58 GMT</pubDate>
    </item>
    <item>
      <title>索引、计数、偏移、大小</title>
      <link>https://www.reddit.com/r/programming/comments/1rato8d/index_count_offset_size/</link>
      <description><![CDATA[ 由   提交 /u/matklad   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1rato8d/index_count_offset_size/</guid>
      <pubDate>Sat, 21 Feb 2026 15:19:03 GMT</pubDate>
    </item>
    </channel>
</rss>
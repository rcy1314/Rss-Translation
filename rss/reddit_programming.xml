<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sun, 04 Jan 2026 04:14:23 GMT</lastBuildDate>
    <item>
      <title>从实际数据中自主发现物理不变量（无目标变量，无预定义方程）</title>
      <link>https://www.reddit.com/r/programming/comments/1q3fpkv/autonomous_discovery_of_physical_invariants_from/</link>
      <description><![CDATA[大多数“科学人工智能”和方程发现系统都会假设要预测什么。他们指定一个目标变量、一个方程组或一个动态形式，然后优化参数。 这项工作探索...一个不同的目标。 仅给定来自多个系统的原始观测数据，该架构搜索派生量，将异构行为折叠到共享函数关系上。 具体来说，系统： •不假设目标变量， •不假设方程类， •并且不优化预测误差， 相反，它搜索低复杂度的不变量，使不同的系统在共享映射下看起来相同。 在使用 NASA 锂离子电池老化数据的实际测试中，它自动识别热力学效率的不变量，该不变量会破坏不同电池之间的退化轨迹，而不使用容量作为输入或目标。 这项工作的重点是表明，无目标不变发现可以被视为其自身的计算问题，而不是回归、符号方程拟合或 PINN 的变体。 我最终对将其与符号回归、SINDy 或基于 Koopman 的方法进行比较的技术批评感兴趣，因为这里的目标是不变发现，而不是方程拟合。   由   提交 /u/anima-core   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q3fpkv/autonomous_discovery_of_physical_invariants_from/</guid>
      <pubDate>Sun, 04 Jan 2026 03:57:43 GMT</pubDate>
    </item>
    <item>
      <title>一致性哈希中的“热键”危机：当虚拟节点让您失败时</title>
      <link>https://www.reddit.com/r/programming/comments/1q3ev1l/the_hot_key_crisis_in_consistent_hashing_when/</link>
      <description><![CDATA[您已经使用一致性哈希构建了分布式速率限制器或 Websocket 集群。用户 ID 映射到特定服务器，为您提供缓存位置和确定性路由。一切都很完美，直到拥有数百万粉丝的“名人”（或流氓人工智能代理）加入平台。 他们分配的服务器达到 100% CPU 并崩溃。哈希环将该流量转移到下一个服务器，该服务器也会立即崩溃。几分钟之内，您就因级联故障而失去了三台服务器，而其他 95 台服务器则处于闲置状态，CPU 利用率为 5%。 这不是“虚拟节点”问题。这是一个访问倾斜问题，大多数工程师尝试使用错误的工具来解决它。 https://github.com/sysdr/sdir https://sdcourse.substack.com/ https://systemdrd.com/   由   提交/u/Extra_Ear_10   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q3ev1l/the_hot_key_crisis_in_consistent_hashing_when/</guid>
      <pubDate>Sun, 04 Jan 2026 03:17:47 GMT</pubDate>
    </item>
    <item>
      <title>软件工艺已死</title>
      <link>https://www.reddit.com/r/programming/comments/1q3ed1a/software_craftsmanship_is_dead/</link>
      <description><![CDATA[ 由   提交/u/R2_SWE2  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q3ed1a/software_craftsmanship_is_dead/</guid>
      <pubDate>Sun, 04 Jan 2026 02:54:50 GMT</pubDate>
    </item>
    <item>
      <title>新页面添加了“YINI 是什么以及为什么？” - 注重可读性和可预测行为的配置格式</title>
      <link>https://www.reddit.com/r/programming/comments/1q3e8fz/new_page_added_what_is_yini_and_why_a_config/</link>
      <description><![CDATA[大家好，我添加了一个新的“YINI 是什么以及为什么？” YINI 网站上的页面介绍了该格式背后的动机 - 为什么它存在，它解决了哪些问题，以及它与其他配置格式的比较。 如果您喜欢干净、可预测的配置文件，请随时查看。我很想听听您的想法。   由   提交/u/Effective_Tune_6830   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q3e8fz/new_page_added_what_is_yini_and_why_a_config/</guid>
      <pubDate>Sun, 04 Jan 2026 02:48:58 GMT</pubDate>
    </item>
    <item>
      <title>让 Claude Code 与 Windows 98 对话（C 客户端、.NET 代理）</title>
      <link>https://www.reddit.com/r/programming/comments/1q359tj/making_claude_code_talk_to_windows_98_c_client/</link>
      <description><![CDATA[ 由   提交/u/shinto29  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q359tj/making_claude_code_talk_to_windows_98_c_client/</guid>
      <pubDate>Sat, 03 Jan 2026 20:31:11 GMT</pubDate>
    </item>
    <item>
      <title>用纯 C 语言编写 SIMD 优化的 Parquet 库：实施 Thrift 解析、位打包和运行时 CPU 调度的经验教训</title>
      <link>https://www.reddit.com/r/programming/comments/1q3430e/writing_a_simdoptimized_parquet_library_in_pure_c/</link>
      <description><![CDATA[我需要纯 C 项目的 Parquet 支持。 Apache Arrow 的 C 接口实际上是 C++ 的包装器，具有很强的依赖性，因此我从头开始构建了自己的接口（在 Claude Code 的帮助下）。 有趣的技术位： • Thrift Compact 协议 - Parquet 元数据使用 Thrift 序列化。在 C 中实现紧凑的协议解析器意味着无需任何代码生成即可处理变体、zigzag 编码和嵌套结构递归。在您遇到可选字段和复杂模式之前，该规范看似简单。 • 位打包和压缩RLE 混合编码 - Parquet 的整数编码以任意位宽度（1-32 位）打包值。有效地将 8 个值解包为 5 位，需要仔细的位操作。我为每个宽度 1-8 编写了专门的解包程序，然后为更宽的路径编写了 SIMD 版本。 • 运行时 SIMD 调度 - 该库在 init 时检测 CPU 功能（x86 上的 SSE4.2/AVX2/AVX-512，ARM 上的 NEON/SVE）并将函数指针设置为最佳实现。这包括浮点数的 BYTE_STREAM_SPLIT 解码，使用 AVX2 可以将速度提高约 4 倍。 • 跨平台难题 - MSVC 没有 __builtin_ctz 或 __builtin_prefetch。 ARM NEON 内在函数因编译器而异。代码库现在有相当多的 #ifdef 考古学。 结果：基准测试显示 pyarrow 在大文件上的读取性能具有竞争力，静态库约为 50KB，而 Arrow 的多 MB 占用空间。 代码：https://github.com/Vitruves/carquet 很高兴讨论实现细节或采取对这种方法的批评。 祝你度过愉快的一天/晚上/夜晚！   由   提交/u/Vitruves   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q3430e/writing_a_simdoptimized_parquet_library_in_pure_c/</guid>
      <pubDate>Sat, 03 Jan 2026 19:45:13 GMT</pubDate>
    </item>
    <item>
      <title>小程序正式消失，但浏览器中的 Java 比以往任何时候都更好</title>
      <link>https://www.reddit.com/r/programming/comments/1q33u5b/applets_are_officially_gone_but_java_in_the/</link>
      <description><![CDATA[ 由   提交/u/henk53  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q33u5b/applets_are_officially_gone_but_java_in_the/</guid>
      <pubDate>Sat, 03 Jan 2026 19:35:49 GMT</pubDate>
    </item>
    <item>
      <title>当 std::shared_mutex 优于 std::mutex 时：关于扩展和开销的 Google 基准研究</title>
      <link>https://www.reddit.com/r/programming/comments/1q33sj9/when_stdshared_mutex_outperforms_stdmutex_a/</link>
      <description><![CDATA[在这篇文章中，我研究了读取繁重的 C++ 工作负载中 std::mutex 和 std::shared_mutex 之间的性能权衡。对于基准测试，我使用了 Google Benchmark 框架。它基于读写器访问模式，随着读取器并发性的增加，测量每个操作的执行时间。结果显示，线程数较少时 std::mutex 的开销较低，随后出现一个明显的交叉点，其中 std::shared_mutex 在增加读取争用的情况下可以更有效地扩展。   由   提交 /u/Clean-Upstairs-8481   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q33sj9/when_stdshared_mutex_outperforms_stdmutex_a/</guid>
      <pubDate>Sat, 03 Jan 2026 19:34:06 GMT</pubDate>
    </item>
    <item>
      <title>将业务逻辑视为一个单独的、可测试的工件——有人这样做吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1q32xif/treating_business_logic_as_a_separate_testable/</link>
      <description><![CDATA[我一直在思考业务规则如何分散在代码库中——埋藏在服务层中、与验证混合在一起，或者陷入不同步的 Confluence 文档中。 如果业务逻辑是一流的工件怎么办？类似于： yaml 规则： - id: enterprise_discount when: customer_tier: enterprise then:discount_percent: 20  想法是： - 规则是声明性的，而不是强制性的 - 首先匹配获胜评估（如防火墙规则） - 测试与规则一起进行 - 如果逻辑测试失败，CI 会阻止 PR 这将“应该发生什么”与“应该发生什么”分开来自“它是如何实现的。” 随着人工智能生成更多代码，我一直想知道实现是否变得比逻辑本身更有价值。代码可以重新生成——但业务决策才是真正定义产品的因素。 有人在这样的系统上工作过吗？对现有技术、模式或为什么这可能是一个糟糕的想法感到好奇。   由   提交/u/One_Lengthiness1685   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q32xif/treating_business_logic_as_a_separate_testable/</guid>
      <pubDate>Sat, 03 Jan 2026 19:01:19 GMT</pubDate>
    </item>
    <item>
      <title>Naughty Words Every Programmer Should Know - 一本使用 NSFW 缩写词作为助记符的免费电子书</title>
      <link>https://www.reddit.com/r/programming/comments/1q31uq9/naughty_words_every_programmer_should_know_a_free/</link>
      <description><![CDATA[ 由   提交/u/Mrsomud007  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q31uq9/naughty_words_every_programmer_should_know_a_free/</guid>
      <pubDate>Sat, 03 Jan 2026 18:20:43 GMT</pubDate>
    </item>
    <item>
      <title>Bold December 摘要（支持 lsp 和 dap 的文本编辑器）</title>
      <link>https://www.reddit.com/r/programming/comments/1q30n5l/bold_december_summary_text_editor_with_lsp_and/</link>
      <description><![CDATA[ 由   提交 /u/levodelellis   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q30n5l/bold_december_summary_text_editor_with_lsp_and/</guid>
      <pubDate>Sat, 03 Jan 2026 17:35:20 GMT</pubDate>
    </item>
    <item>
      <title>谁拥有内存？第 1 部分：什么是对象？</title>
      <link>https://www.reddit.com/r/programming/comments/1q2y2hc/who_owns_the_memory_part_1_what_is_an_object/</link>
      <description><![CDATA[ 由   提交/u/Luke_Fleed  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2y2hc/who_owns_the_memory_part_1_what_is_an_object/</guid>
      <pubDate>Sat, 03 Jan 2026 15:56:54 GMT</pubDate>
    </item>
    <item>
      <title>使用 Swift 进行原生 Android 应用程序开发</title>
      <link>https://www.reddit.com/r/programming/comments/1q2wl9i/native_android_application_development_in_swift/</link>
      <description><![CDATA[大家好，imike。 我刚刚发布了Swift Stream IDE v1.17.0，它添加了完全用 Swift 编写的完整原生 Android 应用程序开发。这意味着您现在可以构建 Android 应用程序，而无需接触 XML、Java 或 Kotlin。 Swift Stream IDE 是一个开源 VSCode 扩展，它在 Docker 中设置一个即用型 Swift 开发环境，支持服务器端、Web、嵌入式以及现在的完整 Android 开发。在此版本中，您可以使用熟悉的模板（如空活动、基本视图（两个片段）或导航 UI（选项卡栏））创建 Android 应用程序，所有这些都在 Swift 中。 在幕后，所有项目均由 SwifDroid 提供支持，这是我为包装整个原生 Android 应用程序模型而构建的框架。它处理应用程序生命周期和清单、活动和片段、Android、AndroidX、Material 和 Flexbox UI 小部件，甚至自动连接 Gradle 依赖项。支持的 SDK 为 28 至 35，对于 Swift 6.3，可能会下降至 24+。 示例 UI 代码： ConstraintLayout { VStack { TextView(&quot;Hello from Swift!&quot;) .width(.matchParent) .height(.wrapContent) .textColor(.green) MaterialButton(&quot;Tap Me&quot;) .onClick { print(&quot;Button tapped!&quot;) } } .centerVertical() .leftToParent() .rightToParent() }  第一次创建项目时，给自己做一个杯子茶/咖啡。 IDE 提取 Swift 工具链、Android SDK 和 NDK，并将它们缓存在 Docker 卷中。之后，立即创建新项目。第一个构建编译 Swift，生成完整的 Android 项目（准备在 Android Studio 中打开），并创建 Gradle 包装器。之后，构建只需几秒钟。 编译 Swift 后，您只需打开 Android Studio 中的 Application 文件夹，然后点击“运行”或“重新启动”即可查看更改。 Swift Stream IDE 中的所有必要文件均已就位，因此迭代快速且无缝。 这是第一个公开版本。 Android 很大，仍然有一些小部件正在开发中，但该系统今天是真实可用的。 文档：https://docs.swifdroid.com/app/   由   提交/u/imike3049  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2wl9i/native_android_application_development_in_swift/</guid>
      <pubDate>Sat, 03 Jan 2026 14:57:05 GMT</pubDate>
    </item>
    <item>
      <title>身份是一种物理财产，而不是数字许可</title>
      <link>https://www.reddit.com/r/programming/comments/1q2vf8z/identity_is_a_physical_property_not_a_digital/</link>
      <description><![CDATA[问题 如今，几乎所有防伪或身份验证系统都以数字身份开始，并尝试将其附加到物理事物上。 QR 码、序列号、NFC 标签、云验证，甚至基于 ML 的“真假”分析图像检查——它们都有一个假设：数字层是事实的来源。物理对象只是一个载体。 这种假设开始感觉倒退了。 核心思想：提取，而不是分配 如果一个物理对象在其创建过程中已经形成了一个独特的、可测量的身份（微观错位、印刷缺陷、层偏移）怎么办？ 如果我们不把数字代码粘在上面，而只是测量已经存在的东西，会怎么样？那里并使数字层成为该物理指纹的参考？ 这就是 PBM（基于视角的标记）的前提。这是一个简单的物理层实验。 工作原理（简单版本） 设置故意采用低技术含量：  打印两个高频网格图案，一个在另一个上面，它们之间有一个微小的、固定的物理间隙（毫米）。 从一个小角度捕获图像。 物理部分：如果是真实的3D 间隙存在，您会得到视差（网格在图像中相对于彼此移动）。如果是平面照片、屏幕重播或重印，视差场就会崩溃。数学是二进制的。  它不使用什么 这是重要的部分：  没有神经网络 没有“AI 置信度得分” 没有用于核心验证的云 API 调用 没有训练数据或启发式  它使用什么  确定性信号处理：FFT 和相位相关。 简单的信噪比阈值。 输出为 PHYSICAL、NON_PHYSICAL 或 UNDECIDABLE。  UNDECIDABLE 结果是故意的。如果信号不明确，系统会声明“我不知道”。它不会猜测。这感觉比幻觉确定性的系统更健康。 经过测试的绕过方法（它们失败了） 我尝试了明显的攻击：  拍摄令牌照片并将其打印 在手机屏幕上显示令牌 高分辨率重印对于人眼来说，它们看起来很完美。他们甚至可能会传递“强烈信号”查看。但是两个网格层之间的相对视差呢？零。物理不会协商。  你可以自己尝试（认真地）你不需要实验室。要看到视差效果：  一台喷墨打印机 A4纸 CD盒之类的垫片，用于形成间隙 一滴食用油（使最上面的纸半透明并看到两层）这足以观察核心原理。  为什么公开发布此内容？我不想让它变成这样变成：  “信任我们的专有模型” “上传到我们的验证 API” “可用企业定价”  这描述了基于物理的约束，而不是产品。如果这个方法有缺陷，我希望它被公开打破。如果它是有效的，它应该属于任何理解数学的人。 存储库和完整的技术规范是公开的（评论中的链接）。我很高兴讨论为什么这可能是一个死胡同，或者它在哪里可能真正有用。 新年快乐。 https://github.com/illegal-instruction-co/pbm-core   由   提交/u/Humble-Plastic-5285   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2vf8z/identity_is_a_physical_property_not_a_digital/</guid>
      <pubDate>Sat, 03 Jan 2026 14:05:34 GMT</pubDate>
    </item>
    <item>
      <title>以单一文本格式封装音频元数据和编辑逻辑</title>
      <link>https://www.reddit.com/r/programming/comments/1q2rvgs/encapsulating_audio_metadata_and_edit_logic_in_a/</link>
      <description><![CDATA[CUE 表描述了音频时间戳和元数据，但我想要更具表现力的东西。我构建了一个基于 CUE 的文本格式和一个具有类似 SQL 方法的工具，使其小巧且易于实现，同时允许简单但有效的编辑。 在演示中，仅使用 MP3 拖动和播放即可创建专辑混合曲。拖放和文本复制/粘贴—无需波形编辑。   由   提交 /u/cutandjoin   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2rvgs/encapsulating_audio_metadata_and_edit_logic_in_a/</guid>
      <pubDate>Sat, 03 Jan 2026 10:58:15 GMT</pubDate>
    </item>
    </channel>
</rss>
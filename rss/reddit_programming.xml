<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Fri, 02 Jan 2026 09:30:28 GMT</lastBuildDate>
    <item>
      <title>Chris Lattner 从 Swift 到 Mojo 以及高性能人工智能工程</title>
      <link>https://www.reddit.com/r/programming/comments/1q1tqv5/from_swift_to_mojo_and_highperformance_ai/</link>
      <description><![CDATA[ 由   提交/u/Austin_Aaron_Conlon   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1tqv5/from_swift_to_mojo_and_highperformance_ai/</guid>
      <pubDate>Fri, 02 Jan 2026 08:54:28 GMT</pubDate>
    </item>
    <item>
      <title>适用于索尼 NW-A306 的软件工具</title>
      <link>https://www.reddit.com/r/programming/comments/1q1spdk/software_tool_for_sony_nwa306/</link>
      <description><![CDATA[我正在尝试开发一种工具来管理索尼 Walkman NW-A306，类似于 Odin 对三星智能手机所做的操作，但我的编程技能非常有限。有人有兴趣参与这个项目吗？ 目前，最终用户无法在软件损坏的情况下管理设备。 任何帮助将不胜感激   由   提交 /u/MouseAlternative2665   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1spdk/software_tool_for_sony_nwa306/</guid>
      <pubDate>Fri, 02 Jan 2026 07:48:45 GMT</pubDate>
    </item>
    <item>
      <title>开源音乐制作——潜在的 GitHub 平行产品</title>
      <link>https://www.reddit.com/r/programming/comments/1q1sdl9/opensource_music_production_a_potential_github/</link>
      <description><![CDATA[嘿那里， 很快，我会在这篇文章中包含图像来表达观点，但它们是不允许的，所以你必须参考这里的思维导图图像预览。 其中有一些软件框架整体概述的图像预览，以及哲学将成为通往开源音乐制作之路的基础，以及维基百科页面上关于“开放音乐”的有趣引用的屏幕截图，他们描述了类似的东西，但具有讽刺意味的是，并没有完全达到我所设想的来源。 现在最重要的是心智模型、想法、等等。 所以看一下，用你可用的时间和精力分析你能分析的内容。仅仅由于时间限制，让更多人支持这一点就太好了，但无论如何，无论是想法还是基础设施，开发都将继续。 我的目的只是提供模型供您访问、查看和/或编辑，以推动这一进程。为什么？那是在地图上。谁、什么、何时、何地、为什么、如何，都在地图中，所以看一下。 我就把它留在这里... GitHub 存储库 谢谢 fam， v3i1ix   由   提交 /u/trncmshrm   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1sdl9/opensource_music_production_a_potential_github/</guid>
      <pubDate>Fri, 02 Jan 2026 07:28:31 GMT</pubDate>
    </item>
    <item>
      <title>零租金架构：为斯沃特兰农民设计</title>
      <link>https://www.reddit.com/r/programming/comments/1q1sclq/the_zerorent_architecture_designing_for_the/</link>
      <description><![CDATA[ 由   提交 /u/Happy-Snapper   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1sclq/the_zerorent_architecture_designing_for_the/</guid>
      <pubDate>Fri, 02 Jan 2026 07:26:50 GMT</pubDate>
    </item>
    <item>
      <title>修补：无聊的安全实践可以为您节省 7 亿美元</title>
      <link>https://www.reddit.com/r/programming/comments/1q1r2a8/patching_the_boring_security_practice_that_could/</link>
      <description><![CDATA[ 由   提交/u/trolleid   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1r2a8/patching_the_boring_security_practice_that_could/</guid>
      <pubDate>Fri, 02 Jan 2026 06:12:21 GMT</pubDate>
    </item>
    <item>
      <title>Bundler 能像 uv 一样快吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1q1r096/can_bundler_be_as_fast_as_uv/</link>
      <description><![CDATA[ 由   提交/u/iamkeyur  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1r096/can_bundler_be_as_fast_as_uv/</guid>
      <pubDate>Fri, 02 Jan 2026 06:09:16 GMT</pubDate>
    </item>
    <item>
      <title>哈希表合并的经验教训</title>
      <link>https://www.reddit.com/r/programming/comments/1q1pbdk/lessons_from_hash_table_merging/</link>
      <description><![CDATA[ 由   提交/u/attractivechaos   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1pbdk/lessons_from_hash_table_merging/</guid>
      <pubDate>Fri, 02 Jan 2026 04:41:25 GMT</pubDate>
    </item>
    <item>
      <title>coco：一个简单的无堆栈、单线程、仅头文件的 C++20 协程库</title>
      <link>https://www.reddit.com/r/programming/comments/1q1nrd8/coco_a_simple_stackless_singlethreaded_and/</link>
      <description><![CDATA[大家好，我使用 C++20 协程 API 重写了我的协程库 coco。   由   提交/u/Ill_Excuse_4​​291   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1nrd8/coco_a_simple_stackless_singlethreaded_and/</guid>
      <pubDate>Fri, 02 Jan 2026 03:24:14 GMT</pubDate>
    </item>
    <item>
      <title>文章：为什么大型科技公司将一切变成一场刀战</title>
      <link>https://www.reddit.com/r/programming/comments/1q1j104/article_why_big_tech_turns_everything_into_a/</link>
      <description><![CDATA[对于那些因大型科技政治、表演性合作和无休止的内部刀战而疲惫不堪的人来说，这是一本精神错乱但诚实的读物。 我写这本书的部分原因是为了理解自己的经历，部分原因是为了看看是否有办法让企业环境不那么充满敌意——或者至少是为了娱乐以前看过这部电影的无聊工程师。 考虑将其扩展为成熟的电影科技兄弟传奇。希望得到反馈、角色想法或您希望看到的故事。   由   提交 /u/NoVibeCoding   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1j104/article_why_big_tech_turns_everything_into_a/</guid>
      <pubDate>Thu, 01 Jan 2026 23:48:41 GMT</pubDate>
    </item>
    <item>
      <title>Gene——一种围绕通用“Gene”数据类型构建的同像通用语言</title>
      <link>https://www.reddit.com/r/programming/comments/1q1e75u/gene_a_homoiconic_generalpurpose_language_built/</link>
      <description><![CDATA[嗨， 我一直在研究 Gene，这是一种通用的同像语言，具有类似 Lisp 的表面语法，但其核心数据模型有意不仅仅是“一路向下列出”。 独特之处：Gene 数据类型 Gene 的中心思想是一个始终承载的单一统一结构(1) 类型，(2) 键/值属性，以及 (3) 位置子项： (type ^prop1 value1 ^prop2 value2 child1 child2 ...)  关键点是类型、每个属性值和每个子项本身可以是任何基因数据。一切都是统一的。实际上，这是强大且自由的：您可以构建丰富的自描述结构，而无需转义到不同的“元”表示，并且 AST 和运行时值共享相同的形状。 这不是 JSON，也不是普通的 S 表达式：类型 + 属性 + 子元素在一个表示中是一流的，因此您可以在没有包装器节点的情况下附加结构化元数据，并构建 DSL / 转换，而无需发明单独的注释系统。 动态 + 通用（FP 和 OOP） Gene 的目标是可用于“常规编程”，而不仅仅是 DSL：  FP 风格的基础知识：fn、面向表达式的代码和 AST 友好的表示 OOP 支持：类、新的、嵌套类、命名空间（仍在扩大覆盖范围） 运行时/工具：字节码编译器 + 堆栈Nim 中的 VM，加上 CLI 工具（运行、eval、repl、解析、编译）  类宏功能：未评估的参数 + 调用者上下文评估 Gene 支持未评估的参数和调用者上下文评估（类似宏的行为）。您可以传递表达式而不评估它们，然后在需要时在调用者的上下文中显式评估它们（例如，通过诸如 caller_eval / fn! 之类的原语用于宏样式形式）。这是为了更容易地编写 DSL-ish 控制表单，而无需将评估规则硬编码到核心语言中。 我还添加了一个可选的本地 LLM 后端：Gene 有一个 Genex/llm 命名空间，可以通过 FFI 通过 llama.cpp 调用本地 GGUF 模型（主要是因为我想要无需外部服务的本地推理）。 Repo：https://github.com/gene-lang/gene 我希望获得以下方面的反馈：  “type/props/children”核心结构与普通的 s-exprs 相比是否令人信服， 宏/未评估的参数人体工程学（感觉是否连贯？）， 以及下一步如何使该项目最有用（stdlib、互操作、文档、性能等）。    由   提交/u/gcao99  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1e75u/gene_a_homoiconic_generalpurpose_language_built/</guid>
      <pubDate>Thu, 01 Jan 2026 20:29:38 GMT</pubDate>
    </item>
    <item>
      <title>改变是所有（邪恶）错误的根源</title>
      <link>https://www.reddit.com/r/programming/comments/1q1d0pn/change_is_the_root_of_all_evil_bugs/</link>
      <description><![CDATA[ 由   提交/u/fernandohur  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1d0pn/change_is_the_root_of_all_evil_bugs/</guid>
      <pubDate>Thu, 01 Jan 2026 19:42:20 GMT</pubDate>
    </item>
    <item>
      <title>分布式计算的 8 个谬误：您需要知道的一切 + 为什么它在 2026 年仍然重要</title>
      <link>https://www.reddit.com/r/programming/comments/1q1cblg/the_8_fallacies_of_distributed_computing_all_you/</link>
      <description><![CDATA[ 由   提交/u/trolleid   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1cblg/the_8_fallacies_of_distributed_computing_all_you/</guid>
      <pubDate>Thu, 01 Jan 2026 19:15:08 GMT</pubDate>
    </item>
    <item>
      <title>我分析了 1,398 个 GitHub 问题，以找出开发人员真正遇到的困难 - 以下是我了解到的内容</title>
      <link>https://www.reddit.com/r/programming/comments/1q1c4v8/i_analyzed_1398_github_issues_to_find_what/</link>
      <description><![CDATA[ 由   提交/u/Peach_Baker  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1c4v8/i_analyzed_1398_github_issues_to_find_what/</guid>
      <pubDate>Thu, 01 Jan 2026 19:07:54 GMT</pubDate>
    </item>
    <item>
      <title>根据 r/LocalLLaMA 和社区反馈编写了本地 AI 编码指南</title>
      <link>https://www.reddit.com/r/programming/comments/1q1c37w/compiled_a_guide_to_local_ai_coding_from/</link>
      <description><![CDATA[花时间阅读 r/LocalLLaMA、HN 和开发论坛。将最佳设置、基准测试和陷阱编译成一份指南。涵盖 Ollama、Qwen、Continue dot dev、硬件要求、常见错误。 Github   由   提交/u/Successful-Tax6498   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1c37w/compiled_a_guide_to_local_ai_coding_from/</guid>
      <pubDate>Thu, 01 Jan 2026 19:06:03 GMT</pubDate>
    </item>
    <item>
      <title>热门观点：我们使用人工智能作为飞行前的公关审核员和验证员，以缩短审核时间并节省认知工作。</title>
      <link>https://www.reddit.com/r/programming/comments/1q19wnp/hot_take_we_used_ai_as_a_preflight_pr_reviewer/</link>
      <description><![CDATA[大多数 AI-in-dev 讨论都是关于代码生成，但我们的瓶颈是代码审查。  我们还不希望人工智能做出架构决策，所以我们只让它处理验证：“这个 PR 是否遵循我们已经商定的规则？”而不是“这是一个好的设计吗？”。 基本蓝图： - 存储库中的说明（架构边界、分析模式、访问控制规则等） - AI 在人类看到 PR 之前运行（在差异上进行飞行前，而不是队列中的另一个审阅者） - 输出按严重性构建（阻塞/高/中/低）以避免噪音 -人工智能标记验证类问题（缺少分析参数、设计模式违规、访问检查、TODO/调试代码），而人类专注于判断 最大的变化？并不是说“人工智能捕获了一切”，而是开发人员在要求同事审查之前就开始解决明显的问题。这开始节省每个人的时间和精力！ 我在这里写了完整的工作流程文章（包含示例说明文件、严重性标准等）： https://blog.groundctrl.dev/boost-your-software-team-productivity-with-ai-driven-pr-reviews-a-step-by-step-guide  我很好奇这与其他团队的经验如何相符： - 您是否在验证审查层（清单、模式、分析、访问控制）尝试过人工智能，或者仅用于代码生成？  - 在信任机器人对你的 PR 发表评论之前，你会坚持什么护栏（或者你见过的恐怖故事）？ - 一般来说，你们对人工智能的信任是什么？    由   提交/u/benglorious  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q19wnp/hot_take_we_used_ai_as_a_preflight_pr_reviewer/</guid>
      <pubDate>Thu, 01 Jan 2026 17:40:13 GMT</pubDate>
    </item>
    </channel>
</rss>
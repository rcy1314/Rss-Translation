<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 12 Feb 2026 21:40:12 GMT</lastBuildDate>
    <item>
      <title>仅使用指南针和直尺结构实现了 Game Boy ALU。启动 Pokémon Red 需要 15 分钟。</title>
      <link>https://www.reddit.com/r/programming/comments/1r369xr/implemented_a_game_boy_alu_using_only_compass_and/</link>
      <description><![CDATA[CasNum，一个仅使用圆规和直尺结构实现任意精度算术的库。在此系统中，数字 x 表示为 2D 平面中的点 (x,0)。每个操作不是标准的按位逻辑，而是一个字面上的几何事件：加法是通过中点找到的，而乘法和除法是从三角形相似性导出的。为了证明这个概念，我将此引擎集成到修改后的 Game Boy 模拟器中。它在数学上是纯粹的，在功能上是“可玩的”。在 1~0.5 FPS 下，需要求解 4 次多项式才能增加循环计数器。   由   提交/u/0x0mer  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r369xr/implemented_a_game_boy_alu_using_only_compass_and/</guid>
      <pubDate>Thu, 12 Feb 2026 21:37:07 GMT</pubDate>
    </item>
    <item>
      <title>“观察记忆”将 AI 代理的成本降低了 10 倍，并在长上下文基准测试中超越了 RAG</title>
      <link>https://www.reddit.com/r/programming/comments/1r3659v/observational_memory_cuts_ai_agent_costs_10x_and/</link>
      <description><![CDATA[&quot;与动态检索上下文的 RAG 系统不同，观察记忆使用两个后台代理（观察者和反射器）将对话历史记录压缩到带日期的观察日志中。压缩的观察结果保留在上下文中，完全消除了检索。对于文本内容，系统实现了3-6倍的压缩。对于生成大量输出的工具繁重的代理工作负载，压缩比达到 5-40 倍。”   由   提交/u/thehashimwarren  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r3659v/observational_memory_cuts_ai_agent_costs_10x_and/</guid>
      <pubDate>Thu, 12 Feb 2026 21:32:06 GMT</pubDate>
    </item>
    <item>
      <title>我尝试实现 2024 年 USENIX 关于缓存的论文。这是发生的事情。</title>
      <link>https://www.reddit.com/r/programming/comments/1r34gxs/i_tried_to_implement_a_2024_usenix_paper_on/</link>
      <description><![CDATA[ 由   提交 /u/wineandcode   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r34gxs/i_tried_to_implement_a_2024_usenix_paper_on/</guid>
      <pubDate>Thu, 12 Feb 2026 20:27:34 GMT</pubDate>
    </item>
    <item>
      <title>设计每秒 25 亿次操作的 secp256k1 引擎</title>
      <link>https://www.reddit.com/r/programming/comments/1r30he3/engineering_a_25_billion_opssec_secp256k1_engine/</link>
      <description><![CDATA[https://medium.com/@payysoon/engineering-a-2-5-billion-ops-sec-secp256k1-engine-a46484c690c7   由   提交/u/Available-Young251  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r30he3/engineering_a_25_billion_opssec_secp256k1_engine/</guid>
      <pubDate>Thu, 12 Feb 2026 18:00:32 GMT</pubDate>
    </item>
    <item>
      <title>在成熟的存储和WAL级复制之上组成KV层</title>
      <link>https://www.reddit.com/r/programming/comments/1r2zxk1/composing_a_kv_layer_over_mature_storage_and/</link>
      <description><![CDATA[大多数键值存储要么实现自定义存储引擎，要么直接将复制嵌入到系统中。我一直在探索一种不同的架构方法：保持 KV 层的薄型，并将其构建在成熟的 B 树 + WAL 组件之上，这些组件已经提供了持久性和崩溃恢复保证。 无需引入自定义复制协议，WAL 级复制可以通过 LiteFS 等成熟工具来处理。在此模型中，复制完全在 KV 抽象边界下运行，因此 KV 层本身保持简单，并且不管理领导者选举、日志传送或分布式状态。 这提出了一个架构问题：从经过良好测试的存储原语和外部复制工具组成系统，而不是从头开始设计紧密集成的 KV 引擎，这有多可行？ 用于这些实验的最小参考实现是 SNKV： https://github.com/hash-anu/snkv 很想听听有关现代存储系统中可组合性与自定义引擎设计的观点。   由   提交/u/Fine-Package-5488   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2zxk1/composing_a_kv_layer_over_mature_storage_and/</guid>
      <pubDate>Thu, 12 Feb 2026 17:40:21 GMT</pubDate>
    </item>
    <item>
      <title>2025 年维基百科上浏览次数最多的人物</title>
      <link>https://www.reddit.com/r/programming/comments/1r2zr0h/mostviewed_people_on_wikipedia_in_2025/</link>
      <description><![CDATA[ 由   提交/u/sataky  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2zr0h/mostviewed_people_on_wikipedia_in_2025/</guid>
      <pubDate>Thu, 12 Feb 2026 17:33:34 GMT</pubDate>
    </item>
    <item>
      <title>一切花费的时间比你想象的要长</title>
      <link>https://www.reddit.com/r/programming/comments/1r2ygb6/everything_takes_longer_than_you_think/</link>
      <description><![CDATA[ 由   提交/u/AltruisticPrimary34  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2ygb6/everything_takes_longer_than_you_think/</guid>
      <pubDate>Thu, 12 Feb 2026 16:45:59 GMT</pubDate>
    </item>
    <item>
      <title>学习基础知识，而不是框架</title>
      <link>https://www.reddit.com/r/programming/comments/1r2xh88/learn_fundamentals_not_frameworks/</link>
      <description><![CDATA[ 由   提交/u/milanm08  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2xh88/learn_fundamentals_not_frameworks/</guid>
      <pubDate>Thu, 12 Feb 2026 16:09:11 GMT</pubDate>
    </item>
    <item>
      <title>氚|感谢所有框架：Rust GUI 观察</title>
      <link>https://www.reddit.com/r/programming/comments/1r2wd51/tritium_thanks_for_all_the_frames_rust_gui/</link>
      <description><![CDATA[ 由   提交 /u/urandomd   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2wd51/tritium_thanks_for_all_the_frames_rust_gui/</guid>
      <pubDate>Thu, 12 Feb 2026 15:26:46 GMT</pubDate>
    </item>
    <item>
      <title>从备份中快速恢复 1M+ 文件</title>
      <link>https://www.reddit.com/r/programming/comments/1r2vraq/quickly_restoring_1m_files_from_backup/</link>
      <description><![CDATA[ 由   提交/u/axkotti   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2vraq/quickly_restoring_1m_files_from_backup/</guid>
      <pubDate>Thu, 12 Feb 2026 15:03:51 GMT</pubDate>
    </item>
    <item>
      <title>Quarkus 中的 PDF 生成：实用、高性能且原生</title>
      <link>https://www.reddit.com/r/programming/comments/1r2uluk/pdf_generation_in_quarkus_practical_performant/</link>
      <description><![CDATA[ 由   提交/u/Active-Fuel-49  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2uluk/pdf_generation_in_quarkus_practical_performant/</guid>
      <pubDate>Thu, 12 Feb 2026 14:18:24 GMT</pubDate>
    </item>
    <item>
      <title>Q-Day 之后：大规模量子应用 • Matthew Keesan</title>
      <link>https://www.reddit.com/r/programming/comments/1r2tg1a/after_qday_quantum_applications_at_scale_matthew/</link>
      <description><![CDATA[ 由   提交 /u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2tg1a/after_qday_quantum_applications_at_scale_matthew/</guid>
      <pubDate>Thu, 12 Feb 2026 13:29:30 GMT</pubDate>
    </item>
    <item>
      <title>代码行又回来了（而且比以前更糟糕）</title>
      <link>https://www.reddit.com/r/programming/comments/1r2t1ea/lines_of_code_are_back_and_its_worse_than_before/</link>
      <description><![CDATA[ 由   提交/u/amacgregor  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2t1ea/lines_of_code_are_back_and_its_worse_than_before/</guid>
      <pubDate>Thu, 12 Feb 2026 13:11:31 GMT</pubDate>
    </item>
    <item>
      <title>如何在内核中运行用户层代码：编写更快的“top”</title>
      <link>https://www.reddit.com/r/programming/comments/1r2sx3u/how_to_run_your_userland_code_inside_the_kernel/</link>
      <description><![CDATA[ 由   提交/u/Kai_  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2sx3u/how_to_run_your_userland_code_inside_the_kernel/</guid>
      <pubDate>Thu, 12 Feb 2026 13:06:00 GMT</pubDate>
    </item>
    <item>
      <title>分析和修复 RocksDB 摄取：1M 行速度提高 23 倍</title>
      <link>https://www.reddit.com/r/programming/comments/1r2stkm/profiling_and_fixing_rocksdb_ingestion_23_faster/</link>
      <description><![CDATA[我们将 1M 行（650MB，120 列）ClickBench 子集加载到我们的 RocksDB 支持的引擎中，大约花费了 180 秒。这感觉……错了。 在使用性能和火焰图进行分析后，我们发现了一系列致命的问题：  使用 Transaction::Put 进行批量加载（大量锁定+排序开销） 过滤+压缩工作无论如何都会在压缩过程中重做 热 CSV 解析路径中的 sscanf 逐字节字符串追加 SstFileWriter 内的虚拟调用和原子状态检查 每行每列隐藏字符串副本  也许我们的发现和修复对其他使用 RocksDB 作为存储引擎的人有帮助。 博客文章中的完整文章（带有补丁和火焰图）https://blog.serenedb.com/building-faster-ingestion   由   提交/u/grmpf101  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2stkm/profiling_and_fixing_rocksdb_ingestion_23_faster/</guid>
      <pubDate>Thu, 12 Feb 2026 13:01:38 GMT</pubDate>
    </item>
    </channel>
</rss>
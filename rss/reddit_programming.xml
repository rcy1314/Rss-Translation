<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 06 Nov 2025 12:51:06 GMT</lastBuildDate>
    <item>
      <title>“Vibecoding”被柯林斯词典评为年度词汇</title>
      <link>https://www.reddit.com/r/programming/comments/1opxufs/vibe_coding_named_word_of_the_year_by_collins/</link>
      <description><![CDATA[ 由   提交/u/PleasantSalamander93  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opxufs/vibe_coding_named_word_of_the_year_by_collins/</guid>
      <pubDate>Thu, 06 Nov 2025 12:41:02 GMT</pubDate>
    </item>
    <item>
      <title>我对领导工程团队的错误和建议</title>
      <link>https://www.reddit.com/r/programming/comments/1opxk1n/my_mistakes_and_advice_leading_engineering_teams/</link>
      <description><![CDATA[ 由   提交/u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opxk1n/my_mistakes_and_advice_leading_engineering_teams/</guid>
      <pubDate>Thu, 06 Nov 2025 12:26:56 GMT</pubDate>
    </item>
    <item>
      <title>嵌入 TypeScript</title>
      <link>https://www.reddit.com/r/programming/comments/1opvtk4/embedding_typescript/</link>
      <description><![CDATA[ 由   提交/u/AndrewMD5   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opvtk4/embedding_typescript/</guid>
      <pubDate>Thu, 06 Nov 2025 10:53:07 GMT</pubDate>
    </item>
    <item>
      <title>胶囊碰撞教程</title>
      <link>https://www.reddit.com/r/programming/comments/1opvieb/capsule_collision_tutorial/</link>
      <description><![CDATA[ 由   提交/u/PeterBrobby   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opvieb/capsule_collision_tutorial/</guid>
      <pubDate>Thu, 06 Nov 2025 10:34:19 GMT</pubDate>
    </item>
    <item>
      <title>来自“多处理器编程的艺术”的无锁跳表（和列表）到 C++ 的移植</title>
      <link>https://www.reddit.com/r/programming/comments/1opvglp/a_port_of_the_lockfree_skiplist_and_list_to_c/</link>
      <description><![CDATA[如果您删除我实现的类似java的抽象，则可以进一步优化，并且如果您内联所有抽象帮助器而不是使用它们，您可以获得固体T类型而不是我使用的void*数据，但这会使代码不太清晰 就目前情况而言，我使用void*数据是有原因的，这样我就可以保持与&#39;atomicmarkablereference&#39;相同的抽象和与java相同的行为，并导致工作端口 如果您想重新编码该类以将所有 CAS 和其他函数内联，则可以考虑这一点 无论哪种方式，这都是关于如何在 C++ 中实现类似本书的内容的不错的参考 - 暗示了内存管理（完整的 epochmanager 未包含在该项目中，因此该演示在没有完全实现的情况下会泄漏） 编辑： 此端口的技术挑战以及移植 java 无锁代码的技巧到 c++： -将 java 无锁语义移植到 C++ 以及如何做到这一点：  忠实地复制算法 - 即使您必须改变语言语义或做非传统的事情以使其工作（即严格定义的层基类并使用 void* 数据和强制转换来模仿 javas 原子引用和节点行为，而不是使用可重用且现代的模板，此方法将无法像在所有其他方法中看到的那样工作） github上的例子尝试太慢和双重参考成本，也没有忠实地遵循算法） 使语义等效（epoch/hazard/markable ptr设计）找到一种方法来保持算法相同，同时移植并适合有效的内存模型 验证工作基线 - 在使程序成为一个具体的STL漂亮的现代模板之前，没有hax确保列表有效 - 它可能需要一些更改因为 C++ 速度更快，但安全性较差，因此您可能需要在其他地方进行更多重试检查，或者对算法进行一些强化并进行调试。放松。不要放弃。 然后内联/优化/现代化——这一步我还没有完成，你可以通过删除 SNMarkablepointer 类并内联所有 cas 和指针操作来完成，并慢慢找到撤消抽象的方法，因为算法是可靠的  这是成功移植到 C++ 并实际使锁发挥作用的真正挑战，但如果你这样做并考虑非传统选项，你可以成功将java无锁语义移植到C++   由   提交 /u/Slight-Abroad8939   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opvglp/a_port_of_the_lockfree_skiplist_and_list_to_c/</guid>
      <pubDate>Thu, 06 Nov 2025 10:31:20 GMT</pubDate>
    </item>
    <item>
      <title>通过协作提高质量</title>
      <link>https://www.reddit.com/r/programming/comments/1opvcbi/scaling_quality_through_collaboration/</link>
      <description><![CDATA[ 由   提交/u/ArtisticProgrammer11  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opvcbi/scaling_quality_through_collaboration/</guid>
      <pubDate>Thu, 06 Nov 2025 10:24:03 GMT</pubDate>
    </item>
    <item>
      <title>Postgres 就足够了</title>
      <link>https://www.reddit.com/r/programming/comments/1opv75r/postgres_is_enough/</link>
      <description><![CDATA[ 由   提交/u/iamkeyur  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opv75r/postgres_is_enough/</guid>
      <pubDate>Thu, 06 Nov 2025 10:15:16 GMT</pubDate>
    </item>
    <item>
      <title>软件工程师的 21 个 Git 命令</title>
      <link>https://www.reddit.com/r/programming/comments/1opv1xh/the_21_git_commands_for_software_engineers/</link>
      <description><![CDATA[ 由   提交/u/sdxyz42   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opv1xh/the_21_git_commands_for_software_engineers/</guid>
      <pubDate>Thu, 06 Nov 2025 10:06:22 GMT</pubDate>
    </item>
    <item>
      <title>在多语言项目中结合 Java 和 Rust 代码覆盖率</title>
      <link>https://www.reddit.com/r/programming/comments/1opuppc/combine_java_and_rust_code_coverage_in_a_polyglot/</link>
      <description><![CDATA[ 由   提交 /u/_shadowbannedagain   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opuppc/combine_java_and_rust_code_coverage_in_a_polyglot/</guid>
      <pubDate>Thu, 06 Nov 2025 09:45:05 GMT</pubDate>
    </item>
    <item>
      <title>我每天都会针对 node:current 测试 npm 库，因此您不必这样做。从 100 开始，扩展到 10,000+。</title>
      <link>https://www.reddit.com/r/programming/comments/1opuift/im_testing_npm_libs_against_nodecurrent_daily_so/</link>
      <description><![CDATA[这是修改后的 r/node 帖子。此版本清楚地说明了您当前的规模和雄心勃勃的未来计划，这是展示愿景的好方法。 标题： 我每天都在测试 npm 库 node:current ，因此您不必这样做。从 100 开始，扩展到 10,000+。 Body： 嘿， 当新的 Node.js 版本发布时，我们都感到焦虑，想知道“这会在生产中出现什么问题？” 我有一堆闲置的计算能力，所以我构建了一个“金矿里的金丝雀”。系统尝试在这些中断达到稳定之前捕获它们。 现在，我正在测试“概念验证”。 ~100 个库的列表（流行库和 C++ 插件的组合）。我的计划是将其扩展至 10,000+ 最依赖的软件包。 每天执行一次 GitHub 操作：  拉取最新的 node:lts-alpine（稳定）和 node:current-alpine（不稳定）。 克隆库。 强制从源代码编译（--build-from-source）并在两个版本上运行整个测试套件（npm test）。  结果已经证明了这个概念：  node-config**:** SKIPPED（正确标识为“无法测试”）。 fastify**、** express** 等：** 通过（所有标准库均兼容）。  我将所有结果（包含通过/失败日志）放入此公共 report.md 文件，该文件由机器人每天更新。我还在报告中添加了一个点击计数器，以便我们可以看到有多少人在使用它。 您可以在此处查看完整的仪表板/报告： https://github.com/whitestorm007/node-compatibility-dashboard 我向大家提出的问题：  这真的有用吗？ 还有什么其他 C++ 或“片状”功能？我现在应该将库添加到测试列表中吗？ 当我扩展到 10,000 多个库时，什么会让这个仪表板（第 2 阶段）对您或您的团队最有价值？    由   提交/u/whitestorm_07  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opuift/im_testing_npm_libs_against_nodecurrent_daily_so/</guid>
      <pubDate>Thu, 06 Nov 2025 09:32:23 GMT</pubDate>
    </item>
    <item>
      <title>集成 GitButler 和 GitHub Enterprise</title>
      <link>https://www.reddit.com/r/programming/comments/1opu8j9/integrating_gitbutler_and_github_enterprise/</link>
      <description><![CDATA[ 由   提交/u/aspleenic  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opu8j9/integrating_gitbutler_and_github_enterprise/</guid>
      <pubDate>Thu, 06 Nov 2025 09:14:58 GMT</pubDate>
    </item>
    <item>
      <title>学习循环和法学硕士</title>
      <link>https://www.reddit.com/r/programming/comments/1optvxf/the_learning_loop_and_llms/</link>
      <description><![CDATA[“用自然语言表达我们的意图并接收工作代码的能力并不能取代通过学习每种语言的设计、约束和权衡而获得的更深入的理解。”   由   提交/u/fzaninotto  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1optvxf/the_learning_loop_and_llms/</guid>
      <pubDate>Thu, 06 Nov 2025 08:52:05 GMT</pubDate>
    </item>
    <item>
      <title>Voiden：不需要您的电子邮件地址的 API 客户端</title>
      <link>https://www.reddit.com/r/programming/comments/1optsn6/voiden_the_api_client_that_doesnt_want_your_email/</link>
      <description><![CDATA[一路走来，API 工具已经失去了方向。 除了一些好的例外，API 客户端已经变成了臃肿的 SaaS 平台。 Voiden 恰恰相反。 它解决了传统上相当拥挤的 API 开发工具空间。 从技术角度来看，我们只是说构建一个将 Markdown 视为可执行基础设施的基于块的编辑器很有趣。 大多数传统 API 客户端将集合存储在 JSON blob 中，而最近，我们得到了一些基于文件的系统方法的竞争者。 Voiden 将 Markdown 解析为块系统，其中每个 /endpoint、/json、/path-param 、 /header等是可寻址块。这些块可以在整个项目中导入，从而允许继承和覆盖而无需重复。 跨文档同步是值得考虑的。当链接块在源文件中更新时，所有引用都需要反映更改，而不会创建循环依赖项或无限更新循环。同时还必须启用对分离块的控制，或覆盖单个链接字段值（例如单个 json 有效负载字段/对象而不触及其其余部分）。仍然必须避免冗余解析，保持轻量级但功能强大。 最重要的是，正确实现环境变量是一个挑战。 Voiden 使用 .env 和 .env.child 结构，您可以在其中的“父”结构中定义全局环境变量。 .env 文件，然后在子文件中覆盖您想要覆盖的任何内容，而无需列出您喜欢的全局文件 - 再次以熟练程度为目标，避免构建过程中的重复，但更重要的是在编辑阶段。 另一个挑战是解决整个“按席位付费”的问题。用于空间中存在的协作叙事。传统的 API 工具使用专有格式，这会导致云同步最后写入信息丢失，而且对于美化的（和付费的）git 替代品来说，这也是不合理的成本。因此，Voiden 在应用程序中引入了一个终端，您的项目是可比较的，并且可以与 git 协作。 我相信当前版本非常接近对开发社区来说非常有价值的内容，现在为补丁留出了空间（毕竟它是测试版），迭代引入了对其他协议的支持，也许最重要的是，您也可以为插件市场做出贡献。 Voiden 不做的事情：  请求帐户 发送遥测数据 付费墙基本功能 将数据存储在“云端” 需要本地主机的互联网连接  它的作用：  在 Markdown 文件（可执行 .void 格式）中定义、测试和记录 API 版本并与 Git 协作 使用插件进行扩展（用于测试数据的 Faker、OAuth、自定义身份验证） 内置终端（具有多个选项卡） 跨文档链接块，而不是无休止的复制粘贴跳跃（例如，定义身份验证或查询参数一次，通过自动同步在任何地方引用） 导入 Postman 集合和 OpenAPI 规范 使用键盘快捷键、本机菜单和命令面板 (Cmd+Shift+P)，而不是无限循环的选项卡和单击操作 覆盖分层结构中的“.env”字段 覆盖 JSON 字段，而不重复整个对象。 PDF、图像、视频、音频等的响应预览 ...  嗯，它做了很多很酷的事情。 但最酷的是它超轻。 P.S. v1.0 beta 版本 已经发布，距离稳定版本还剩几天时间，还需要几周时间才能开放源代码（是的，我们还在 2025 年）。 P.P.S.您需要什么才能让它变得更好？   由   提交 /u/kiselitza   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1optsn6/voiden_the_api_client_that_doesnt_want_your_email/</guid>
      <pubDate>Thu, 06 Nov 2025 08:46:01 GMT</pubDate>
    </item>
    <item>
      <title>为什么 TypeScript 救不了你</title>
      <link>https://www.reddit.com/r/programming/comments/1opthfc/why_typescript_wont_save_you/</link>
      <description><![CDATA[ 由   提交 /u/cekrem   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opthfc/why_typescript_wont_save_you/</guid>
      <pubDate>Thu, 06 Nov 2025 08:25:13 GMT</pubDate>
    </item>
    <item>
      <title>免费的开源文件扫描器</title>
      <link>https://www.reddit.com/r/programming/comments/1opsy9w/free_opensource_file_scanner/</link>
      <description><![CDATA[ 由   提交/u/JustSouochi  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1opsy9w/free_opensource_file_scanner/</guid>
      <pubDate>Thu, 06 Nov 2025 07:50:43 GMT</pubDate>
    </item>
    </channel>
</rss>
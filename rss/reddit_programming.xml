<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Fri, 02 Jan 2026 06:40:33 GMT</lastBuildDate>
    <item>
      <title>新的 PHP/Laravel 日期包</title>
      <link>https://www.reddit.com/r/programming/comments/1q1rjgb/a_new_phplaravel_dates_package/</link>
      <description><![CDATA[大家好，我构建了一个名为 Dcter 的与 Laravel 兼容的 Composer 包，它使您的项目中不同日历系统之间的转换变得更加容易。 它支持 Hijri (Qamari)、Jalali (Shamsi/Persian)、Gregorian 和 Julian 转换，并附带一些开箱即用的实用实用程序。  在多个日历系统之间转换日期日历（例如，公历 ↔ Hijri、Jalali ↔ 公历） 本地化月份/工作日名称（英语、阿拉伯语、波斯语） 添加/减去天数并计算差异 验证不同日历的日期 在阿拉伯语和英语之间转换数字 返回 Carbon 实例以进行进一步操作 Artisan 命令从终端快速转换  示例 use Dcter; echo Dcter::GregorianToHijri(&#39;2025-03-01&#39;); // 例如，1446-08-29 安装 composer require hanifhefaz/dcter 对于 Laravel 8+，它通过包发现自动注册。 我很想听听是否有人在 Laravel 应用程序中提供多日历支持的用例或改进的想法！ GitHub：https://github.com/hanifhefaz/dcter   由   提交/u/Paper_Jazzlike  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1rjgb/a_new_phplaravel_dates_package/</guid>
      <pubDate>Fri, 02 Jan 2026 06:39:03 GMT</pubDate>
    </item>
    <item>
      <title>修补：无聊的安全实践可以为您节省 7 亿美元</title>
      <link>https://www.reddit.com/r/programming/comments/1q1r2a8/patching_the_boring_security_practice_that_could/</link>
      <description><![CDATA[ 由   提交/u/trolleid   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1r2a8/patching_the_boring_security_practice_that_could/</guid>
      <pubDate>Fri, 02 Jan 2026 06:12:21 GMT</pubDate>
    </item>
    <item>
      <title>Bundler 能像 uv 一样快吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1q1r096/can_bundler_be_as_fast_as_uv/</link>
      <description><![CDATA[ 由   提交/u/iamkeyur  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1r096/can_bundler_be_as_fast_as_uv/</guid>
      <pubDate>Fri, 02 Jan 2026 06:09:16 GMT</pubDate>
    </item>
    <item>
      <title>哈希表合并的经验教训</title>
      <link>https://www.reddit.com/r/programming/comments/1q1pbdk/lessons_from_hash_table_merging/</link>
      <description><![CDATA[ 由   提交/u/attractivechaos   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1pbdk/lessons_from_hash_table_merging/</guid>
      <pubDate>Fri, 02 Jan 2026 04:41:25 GMT</pubDate>
    </item>
    <item>
      <title>coco：一个简单的无堆栈、单线程、仅头文件的 C++20 协程库</title>
      <link>https://www.reddit.com/r/programming/comments/1q1nrd8/coco_a_simple_stackless_singlethreaded_and/</link>
      <description><![CDATA[大家好，我使用 C++20 协程 API 重写了我的协程库 coco。   由   提交/u/Ill_Excuse_4​​291   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1nrd8/coco_a_simple_stackless_singlethreaded_and/</guid>
      <pubDate>Fri, 02 Jan 2026 03:24:14 GMT</pubDate>
    </item>
    <item>
      <title>文章：为什么大型科技公司将一切变成一场刀战</title>
      <link>https://www.reddit.com/r/programming/comments/1q1j104/article_why_big_tech_turns_everything_into_a/</link>
      <description><![CDATA[对于那些因大型科技政治、表演性合作和无休止的内部刀战而疲惫不堪的人来说，这是一本精神错乱但诚实的读物。 我写这本书的部分原因是为了理解自己的经历，部分原因是为了看看是否有办法让企业环境不那么充满敌意——或者至少是为了娱乐以前看过这部电影的无聊工程师。 考虑将其扩展为成熟的电影科技兄弟传奇。希望得到反馈、角色想法或您希望看到的故事。   由   提交 /u/NoVibeCoding   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1j104/article_why_big_tech_turns_everything_into_a/</guid>
      <pubDate>Thu, 01 Jan 2026 23:48:41 GMT</pubDate>
    </item>
    <item>
      <title>Gene——一种围绕通用“Gene”数据类型构建的同像通用语言</title>
      <link>https://www.reddit.com/r/programming/comments/1q1e75u/gene_a_homoiconic_generalpurpose_language_built/</link>
      <description><![CDATA[嗨， 我一直在研究 Gene，这是一种通用的同像语言，具有类似 Lisp 的表面语法，但其核心数据模型有意不仅仅是“一路向下列出”。 独特之处：Gene 数据类型 Gene 的中心思想是一个始终承载着的单一统一结构(1) 类型，(2) 键/值属性，以及 (3) 位置子项： (type ^prop1 value1 ^prop2 value2 child1 child2 ...)  关键点是类型、每个属性值和每个子项本身可以是任何基因数据。一切都是统一的。实际上，这是强大且自由的：您可以构建丰富的自描述结构，而无需转义到不同的“元”表示，并且 AST 和运行时值共享相同的形状。 这不是 JSON，也不是普通的 S 表达式：类型 + 属性 + 子元素在一个表示中是一流的，因此您可以在没有包装器节点的情况下附加结构化元数据，并构建 DSL / 转换，而无需发明单独的注释系统。 动态 + 通用（FP 和 OOP） Gene 的目标是可用于“常规编程”，而不仅仅是 DSL：  FP 风格的基础知识：fn、面向表达式的代码和 AST 友好的表示 OOP 支持：类、新的、嵌套类、命名空间（仍在扩大覆盖范围） 运行时/工具：字节码编译器 + 堆栈Nim 中的 VM，加上 CLI 工具（运行、eval、repl、解析、编译）  类似宏的功能：未评估的参数 + 调用者上下文评估 Gene 支持未评估的参数和调用者上下文评估（类似宏的行为）。您可以传递表达式而不评估它们，然后在需要时在调用者的上下文中显式评估它们（例如，通过诸如 caller_eval / fn! 之类的原语用于宏样式形式）。这是为了更容易地编写 DSL-ish 控制表单，而无需将评估规则硬编码到核心语言中。 我还添加了一个可选的本地 LLM 后端：Gene 有一个 Genex/llm 命名空间，可以通过 FFI 通过 llama.cpp 调用本地 GGUF 模型（主要是因为我想要无需外部服务的本地推理）。 Repo：https://github.com/gene-lang/gene 我希望获得以下方面的反馈：  “type/props/children”核心结构与普通的 s-exprs 相比是否令人信服， 宏/未评估的参数人体工程学（感觉是否连贯？）， 以及下一步如何使该项目最有用（stdlib、互操作、文档、性能等）。    由   提交/u/gcao99  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1e75u/gene_a_homoiconic_generalpurpose_language_built/</guid>
      <pubDate>Thu, 01 Jan 2026 20:29:38 GMT</pubDate>
    </item>
    <item>
      <title>改变是所有（邪恶）错误的根源</title>
      <link>https://www.reddit.com/r/programming/comments/1q1d0pn/change_is_the_root_of_all_evil_bugs/</link>
      <description><![CDATA[ 由   提交/u/fernandohur   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1d0pn/change_is_the_root_of_all_evil_bugs/</guid>
      <pubDate>Thu, 01 Jan 2026 19:42:20 GMT</pubDate>
    </item>
    <item>
      <title>分布式计算的 8 个谬误：您需要知道的一切 + 为什么它在 2026 年仍然重要</title>
      <link>https://www.reddit.com/r/programming/comments/1q1cblg/the_8_fallacies_of_distributed_computing_all_you/</link>
      <description><![CDATA[ 由   提交/u/trolleid   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1cblg/the_8_fallacies_of_distributed_computing_all_you/</guid>
      <pubDate>Thu, 01 Jan 2026 19:15:08 GMT</pubDate>
    </item>
    <item>
      <title>我分析了 1,398 个 GitHub 问题，以找出开发人员真正遇到的困难 - 以下是我了解到的内容</title>
      <link>https://www.reddit.com/r/programming/comments/1q1c4v8/i_analyzed_1398_github_issues_to_find_what/</link>
      <description><![CDATA[ 由   提交/u/Peach_Baker  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1c4v8/i_analyzed_1398_github_issues_to_find_what/</guid>
      <pubDate>Thu, 01 Jan 2026 19:07:54 GMT</pubDate>
    </item>
    <item>
      <title>根据 r/LocalLLaMA 和社区反馈编写了本地 AI 编码指南</title>
      <link>https://www.reddit.com/r/programming/comments/1q1c37w/compiled_a_guide_to_local_ai_coding_from/</link>
      <description><![CDATA[花时间阅读 r/LocalLLaMA、HN 和开发论坛。将最佳设置、基准测试和陷阱编译成一份指南。涵盖 Ollama、Qwen、Continue dot dev、硬件要求、常见错误。 Github   由   提交/u/Successful-Tax6498   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q1c37w/compiled_a_guide_to_local_ai_coding_from/</guid>
      <pubDate>Thu, 01 Jan 2026 19:06:03 GMT</pubDate>
    </item>
    <item>
      <title>热门观点：我们使用人工智能作为飞行前的公关审核员和验证员，以缩短审核时间并节省认知工作。</title>
      <link>https://www.reddit.com/r/programming/comments/1q19wnp/hot_take_we_used_ai_as_a_preflight_pr_reviewer/</link>
      <description><![CDATA[大多数 AI-in-dev 讨论都是关于代码生成，但我们的瓶颈是代码审查。  我们还不希望人工智能做出架构决策，所以我们只让它处理验证：“这个 PR 是否遵循我们已经商定的规则？”而不是“这是一个好的设计吗？”。 基本蓝图： - 存储库中的说明（架构边界、分析模式、访问控制规则等） - AI 在人类看到 PR 之前运行（在差异上进行飞行前，而不是队列中的另一个审阅者） - 输出按严重性构建（阻塞/高/中/低）以避免噪音 -人工智能标记验证类问题（缺少分析参数、设计模式违规、访问检查、TODO/调试代码），而人类专注于判断 最大的变化？并不是说“人工智能捕获了一切”，而是开发人员在要求同事审查之前就开始解决明显的问题。这开始节省每个人的时间和精力！ 我在这里写了完整的工作流程文章（包含示例说明文件、严重性标准等）： https://blog.groundctrl.dev/boost-your-software-team-productivity-with-ai-driven-pr-reviews-a-step-by-step-guide  我很好奇这与其他团队的经验如何相符： - 您是否在验证审查层（清单、模式、分析、访问控制）尝试过人工智能，或者仅用于代码生成？  - 在信任机器人对你的 PR 发表评论之前，你会坚持什么护栏（或者你见过的恐怖故事）？ - 一般来说，你们对人工智能的信任是什么？    由   提交/u/benglorious  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q19wnp/hot_take_we_used_ai_as_a_preflight_pr_reviewer/</guid>
      <pubDate>Thu, 01 Jan 2026 17:40:13 GMT</pubDate>
    </item>
    <item>
      <title>残留物：软件架构中的时间、变化和不确定性 • Barry O'Reilly</title>
      <link>https://www.reddit.com/r/programming/comments/1q19vre/residues_time_change_uncertainty_in_software/</link>
      <description><![CDATA[ 由   提交 /u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q19vre/residues_time_change_uncertainty_in_software/</guid>
      <pubDate>Thu, 01 Jan 2026 17:39:15 GMT</pubDate>
    </item>
    <item>
      <title>解释内存屏障和 Java 的发生在保证之前</title>
      <link>https://www.reddit.com/r/programming/comments/1q161ds/explaining_memory_barriers_and_javas_happens/</link>
      <description><![CDATA[ 由   提交/u/henk53  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q161ds/explaining_memory_barriers_and_javas_happens/</guid>
      <pubDate>Thu, 01 Jan 2026 14:57:34 GMT</pubDate>
    </item>
    <item>
      <title>2026：终端的 Java 年</title>
      <link>https://www.reddit.com/r/programming/comments/1q13d24/2026_the_year_of_java_in_the_terminal/</link>
      <description><![CDATA[ 由   提交/u/henk53  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q13d24/2026_the_year_of_java_in_the_terminal/</guid>
      <pubDate>Thu, 01 Jan 2026 12:41:55 GMT</pubDate>
    </item>
    </channel>
</rss>
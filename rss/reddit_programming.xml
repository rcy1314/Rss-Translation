<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 25 Dec 2025 06:40:30 GMT</lastBuildDate>
    <item>
      <title>我们几年前就“解决”了 C10K，但我们仍在不断重新发明它</title>
      <link>https://www.reddit.com/r/programming/comments/1pv77i3/we_solved_c10k_years_ago_yet_we_keep_reinventing/</link>
      <description><![CDATA[本文解释了今天仍然以不同名称出现的问题。  C10K 并不是真正要“处理 10,000 个用户”，而是要了解系统实际出现故障的位置：阻塞 I/O、每个连接线程模型、内核限制以及有关硬件扩展的天真的假设。  有趣的是，我们经常重新发现相同的约束：  事件循环与线程 背压和资源限制 异步抽象隐藏而不是消除复杂性 解决症状而不是基本原理的框架  现代堆栈（Node.js、async/await、Go、Rust、云负载均衡器）会导致这些问题更容易使用，但权衡并没有消失，它们只是封装得更好。  从一定的距离来看，这读起来不太像历史，而更像是在提醒我们，大多数后端创新都是迭代的，而不是革命性的。   由   提交 /u/Digitalunicon   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pv77i3/we_solved_c10k_years_ago_yet_we_keep_reinventing/</guid>
      <pubDate>Thu, 25 Dec 2025 06:34:21 GMT</pubDate>
    </item>
    <item>
      <title>为人工智能执行构建确定性策略防火墙——希望获得基础设施反馈</title>
      <link>https://www.reddit.com/r/programming/comments/1pv6y6s/building_a_deterministic_policy_firewall_for_ai/</link>
      <description><![CDATA[我正在试验人工智能系统的控制平面风格方法，并寻找基础设施/架构反馈。 该系统位于人工智能（或自动化）和执行之间，并在任何运行之前强制实施严格的策略约束。 要点： - 它不会像法学硕士那样尝试推理 - 意图规范化是尽力而为的，并且可替换 - 策略执行是确定性的，失败时会关闭 - 每个决策都会生成审计跟踪 我一直在金融科技、健康、法律、保险和政府风格的场景中对其进行测试，包括非结构化输入。 这不是监视或报告 - 它会预先阻止执行。 此处回购：https://github.com/LOLA0786/Intent-Engine-Api 真的很好奇： - 你会攻击什么假设？ - 这会在哪里难以操作？ - 在产品中什么会吓到你？   由   提交/u/Unlucky-Ad7349   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pv6y6s/building_a_deterministic_policy_firewall_for_ai/</guid>
      <pubDate>Thu, 25 Dec 2025 06:17:28 GMT</pubDate>
    </item>
    <item>
      <title>Issue2Prompt - Chrome 扩展，为 AI 助手提取 GitHub 问题上下文</title>
      <link>https://www.reddit.com/r/programming/comments/1pv6twd/issue2prompt_chrome_extension_that_extracts/</link>
      <description><![CDATA[在向 AI 助手寻求帮助时，自动执行收集 GitHub 问题上下文的繁琐工作流程。 问题： 在向 ChatGPT 或 Claude 寻求有关 GitHub 问题的帮助时，通常需要手动： • 复制问题标题和描述 • 提取代码块和错误消息 • 总结讨论注释 • 连贯地格式化所有内容 解决方案： 自动提取： • 问题元数据（标题、标签、状态、受让人） • 保留代码块的完整描述 • 错误日志和堆栈跟踪 • 重现步骤 • 相关技术评论 • 链接的PR 和相关问题 主要功能： • 6 个内置模板（错误修复、功能请求、代码审查等） • 具有类似 Handlebars 语法的自定义模板支持 • 用于智能提示生成的可选 OpenAI 集成 • 以 JSON 格式导入/导出模板 • 隐私第一 - 所有数据均保留在本地 技术堆栈：Chrome Manifest V3、Vanilla JavaScript、OpenAI API（可选） 接受反馈和 PR！   由   提交/u/Holiday_Ad_4557   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pv6twd/issue2prompt_chrome_extension_that_extracts/</guid>
      <pubDate>Thu, 25 Dec 2025 06:09:43 GMT</pubDate>
    </item>
    <item>
      <title>使用 Three.js 在浏览器中实现类似 Blender 的建模功能</title>
      <link>https://www.reddit.com/r/programming/comments/1pv62om/implementing_blenderlike_modeling_features_in_the/</link>
      <description><![CDATA[我正在使用 Three.js 构建一个基于 Web 的 3D 建模应用程序，旨在直接在浏览器中实现类似 Blender 的建模功能（顶点、边、面编辑、捕捉、变换）。 主要的技术挑战是设计一个自定义网格数据结构来存储基于多边形的拓扑而不是仅三角形的几何图形。所有建模工具都在此网格结构上运行，然后将其转换为可渲染的 Three.js 几何体。这允许高效地编辑复杂模型，同时保持拓扑完整。 探索基于网络的建模和实时网格操作是一次令人着迷的旅程，我想分享我在此过程中遇到的一些见解和挑战。   由   提交 /u/Sengchor   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pv62om/implementing_blenderlike_modeling_features_in_the/</guid>
      <pubDate>Thu, 25 Dec 2025 05:20:57 GMT</pubDate>
    </item>
    <item>
      <title>解决人工智能结构化内容爬行效率低下的规范</title>
      <link>https://www.reddit.com/r/programming/comments/1puyk3x/specification_addressing_inefficiencies_in/</link>
      <description><![CDATA[我发布了一份规范草案，解决网络爬虫访问结构化内容为 AI 训练系统创建数据效率低下的问题。 问题陈述 当前的 AI 训练方法依赖于抓取为人类消费而设计的 HTML，带来了三个挑战：  数据质量下降：从 HTML 中提取内容会产生被导航元素、广告、广告等污染的数据集。和表示标记，需要大量的后处理并降低培训质量 基础设施效率低下：大型内容索引系统处理大量的 HTML/CSS/JavaScript，其中很大一部分作为表示标记而不是语义内容被丢弃 法律和道德模糊性：自动抓取在不确定的法律领域进行。希望为 AI 培训贡献高质量内容的网站缺乏标准化机制  技术方法 站点内容协议 (SCP) 为网站提供了一种标准格式，以自愿发布针对自动消费而优化的预生成、压缩内容集合：  采用 gzip/zstd 压缩的结构化 JSON Lines 格式 托管于CDN 或云对象存储 通过标准 sitemap.xml 扩展进行发现 用于高效增量更新的快照和增量架构 与面向人的 HTML 交付完全分离  非常感谢您对格式设计和架构决策的反馈：https://github.com/crawlcore/scp-protocol   由   提交/u/AdhesivenessCrazy950   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1puyk3x/specification_addressing_inefficiencies_in/</guid>
      <pubDate>Wed, 24 Dec 2025 22:06:05 GMT</pubDate>
    </item>
    <item>
      <title>每个程序员都应该知道的数字</title>
      <link>https://www.reddit.com/r/programming/comments/1puwng0/numbers_every_programmer_should_know/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1puwng0/numbers_every_programmer_should_know/</guid>
      <pubDate>Wed, 24 Dec 2025 20:31:57 GMT</pubDate>
    </item>
    <item>
      <title>塞尔达传说：暮光公主已被反编译</title>
      <link>https://www.reddit.com/r/programming/comments/1pussnd/zelda_twilight_princess_has_been_decompiled/</link>
      <description><![CDATA[ 由   提交 /u/r_retrohacking_mod2   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pussnd/zelda_twilight_princess_has_been_decompiled/</guid>
      <pubDate>Wed, 24 Dec 2025 17:36:57 GMT</pubDate>
    </item>
    <item>
      <title>今年教会我的关于工程领导力的知识</title>
      <link>https://www.reddit.com/r/programming/comments/1pupmxb/what_this_year_taught_me_about_engineering/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pupmxb/what_this_year_taught_me_about_engineering/</guid>
      <pubDate>Wed, 24 Dec 2025 15:15:33 GMT</pubDate>
    </item>
    <item>
      <title>选择正确的 C++ 容器以提高性能</title>
      <link>https://www.reddit.com/r/programming/comments/1pup1re/choosing_the_right_c_containers_for_performance/</link>
      <description><![CDATA[我写了一篇关于选择 C++ 容器的短文，重点关注实际系统中的内存布局和性能权衡。它讨论了向量、双端队列和数组何时有意义，以及为什么基于节点的容器通常不适合性能敏感的代码。   由   提交 /u/Clean-Upstairs-8481   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pup1re/choosing_the_right_c_containers_for_performance/</guid>
      <pubDate>Wed, 24 Dec 2025 14:48:54 GMT</pubDate>
    </item>
    <item>
      <title>GitHub 存储库不是文档——不要再像对待文档一样对待它们</title>
      <link>https://www.reddit.com/r/programming/comments/1pun9oq/github_repos_arent_documents_stop_treating_them/</link>
      <description><![CDATA[大多数回购分析工具仍然遵循相同的模式：嵌入每个文件，存储向量，并依赖稍后的检索。 该模型对于文档来说是有意义的。它对于真实的代码库来说是崩溃的。结构、依赖关系和调用流程比孤立的文本相似性更重要。 我在 OpenCV 文章中发现有趣的是思考问题的不同方式： 首先不要索引存储库，而是导航它。 系统从存储库结构开始，然后使用 LLM 来决定对于给定问题哪些文件值得打开。仅在需要时逐步解析代码，并且结果保持在状态中，因此后续问题基于早期上下文而不是重新开始。 这更接近于经验丰富的工程师探索不熟悉的代码的方式：查看布局，打开一些可能的文件，跟踪调用，忽略其余部分。 在这种设置中，嵌入不再是基础，它们只是一种优化。   由   提交/u/Different-Opinion973  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pun9oq/github_repos_arent_documents_stop_treating_them/</guid>
      <pubDate>Wed, 24 Dec 2025 13:22:25 GMT</pubDate>
    </item>
    <item>
      <title>无服务器面板 • N. Coult、R. Kohler、D. Anderson、J. Agarwal、A. Laxmi 和 J. Dongre</title>
      <link>https://www.reddit.com/r/programming/comments/1pun1w0/serverless_panel_n_coult_r_kohler_d_anderson_j/</link>
      <description><![CDATA[ 由   提交/u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pun1w0/serverless_panel_n_coult_r_kohler_d_anderson_j/</guid>
      <pubDate>Wed, 24 Dec 2025 13:11:00 GMT</pubDate>
    </item>
    <item>
      <title>2025 年：SwiftUI 消亡的一年</title>
      <link>https://www.reddit.com/r/programming/comments/1puky96/2025_the_year_swiftui_died/</link>
      <description><![CDATA[ 由   提交/u/jacobs-tech-tavern   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1puky96/2025_the_year_swiftui_died/</guid>
      <pubDate>Wed, 24 Dec 2025 11:07:28 GMT</pubDate>
    </item>
    <item>
      <title>我们在不改变模型权重的情况下将变压器推理调用减少了约 75%（MFEE 控制平面方法）</title>
      <link>https://www.reddit.com/r/programming/comments/1puks9j/we_reduced_transformer_inference_calls_by_75/</link>
      <description><![CDATA[我一直在写一篇系统论文，提出了一个简单的想法：不是优化 Transformer 的运行方式，而是决定它们是否需要运行。 我们引入了意义优先执行 (MFEE)，这是一个控制平面层，用于控制 Transformer 推理并将请求路由到： - RENDER（运行模型） - DIRECT（从缓存/确定性逻辑提供服务） - NO_OP（不执行任何操作） - ABSTAIN（安全拒绝） 在代表性重放工作负载（1,000 个混合提示）上，这将变压器执行量减少了75.1%，同时在调用模型时保持100% 输出等效性。 下面是一个导出的经济影响表，显示了这种减少在规模上意味着什么。这些不是针对任何特定公司的声明，只是根据测量的减少量进行线性推断。 经济影响（派生） 工作负载节省示例（基于原始论文结果）   工作负载类型 每日请求 变压器减少 年度 GPU 成本节省    类似网络搜索 8.5B 75% $2.1B – $4.2B   代码辅助 100M 80% $2.92M – $5.84M   聊天式 LLM 1.5B 70% $511M – $1.0B   企业 API 10M 75% 2700 万美元 – 5500 万美元   假设： - GPU 成本：1.50 美元 - 3.00 美元/小时 - 标准变换器推理成本 - 避免调用的线性缩放 - 基于论文中的75.1% 测量减少 如果您认为这些数字是错误的，则评估harness 是公开的。 令我惊讶的是，生态系统中的大量努力都用于从模型执行中榨取边际收益，而何时需要执行这一更大的问题似乎才是更重要的检查。 MFEE 并不意味着要取代这些优化。它位于它们的上游，从一开始就减少了它们的使用频率。 想法？   由   提交 /u/anima-core   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1puks9j/we_reduced_transformer_inference_calls_by_75/</guid>
      <pubDate>Wed, 24 Dec 2025 10:57:10 GMT</pubDate>
    </item>
    <item>
      <title>为什么运行时环境变量对纯静态网站不起作用</title>
      <link>https://www.reddit.com/r/programming/comments/1puju4z/why_runtime_environment_variables_dont_really/</link>
      <description><![CDATA[ 由   提交 /u/Ok_Animator_1770   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1puju4z/why_runtime_environment_variables_dont_really/</guid>
      <pubDate>Wed, 24 Dec 2025 09:56:52 GMT</pubDate>
    </item>
    <item>
      <title>提交命名系统。</title>
      <link>https://www.reddit.com/r/programming/comments/1pui0hc/commit_naming_system/</link>
      <description><![CDATA[在处理我的一个项目时，我意识到我实际上没有一个好的系统来命名我的提交。我确实使用了 refactor、feat、chore 等类型，但我想要更多的提交名称。这个系统对我来说并不是很清楚，例如删除一个无用的空行是。另外，我希望更清楚地区分用户看到和看不到的事物。 现在我既没有检查其中有多少已经存在，也没有使用过这个系统。另外，这不是演示或炫耀我认为，它应该是关于 git 提交名称的讨论。 这就是我的设想：  基于此约定。 ``` （可选范围）[“！”如果重大更改]：说明 可选正文 可选页脚 ``` 类型按层次结构进行分类：  类别 面向用户：用户注意到这一点。例如新功能、崩溃或 UI 更改。  类别 源代码：对源代码的更改。  type fix：用户可以看到的修复。使用 fix! 进行关键修复，例如崩溃。 type feat：用户看到的功能。  type ui（可选）：仅影响 UI 的更改，如图标更改。这可以标记为壮举或修复。  类别 非源代码：对非源代码的更改。 类型 文档：对向外文档的更改。这也可以是源代码内的文档，例如 UI 中的解释文本。 ---  类别 内部：用户看不到此内容。例如重构、内部文档。  类别 源代码：对源代码的更改。 类型 bug：对用户看不到或几乎没有注意到的问题的修复。 类型 改进：用户看不到的功能。例如：新端点、更好的内部身份验证处理 type refactor：不影响逻辑的内部更改，例如变量名称更改、删除空格。 类别 非源代码：对非源代码的更改。 type chore：对构建过程的更改， config, ... type kbase（用于知识库）：对内部文档的更改重要的是，feat 和 improvement 等类型是等效的，只是属于不同的类别，因此您可以将它们称为  uf/feat 用于面向用户的功能，而 in/feat 用于内部功能，而不是改进。 bug和修复也是如此，你可以用in/fix代替bug。  这就是所谓的类似文件夹的命名。 建议选择全名或类似文件夹的命名，而不是混合使用。  我在不长的时间内起草了这个，所以在执行时没有考虑太多。 它主要处理类型，其余的在我认为的约定中描述。 我想知道你如何命名你的提交，以及你是否认为这样的系统有意义。另外，如果您想扩展它，请继续。   由   提交/u/Tear4Pixelation  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pui0hc/commit_naming_system/</guid>
      <pubDate>Wed, 24 Dec 2025 07:58:15 GMT</pubDate>
    </item>
    </channel>
</rss>
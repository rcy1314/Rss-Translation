<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sat, 24 Jan 2026 18:37:06 GMT</lastBuildDate>
    <item>
      <title>编写一个通用的 JSON.stringify 来序列化任何 C 结构？通过反射使其成为可能的实验</title>
      <link>https://www.reddit.com/r/programming/comments/1qluj9z/writing_a_generic_jsonstringify_that_serializes/</link>
      <description><![CDATA[C 没有模板，也没有本机反射，这通常会导致一个熟悉的问题：任何时候您需要序列化、验证、克隆或遍历结构时，最终都会重复编写相同的逻辑或为每种类型生成大量样板代码。 减少这种重复的一种方法是将元数据生成与运行时逻辑分开。 这篇文章着眼于 Reflect-C，一个探索这一想法的小型 C 项目：它不是为每种类型生成序列化器/解析器，而是在构建时仅生成一个元数据层，然后使用该元数据驱动通用运行时代码。 核心思想 在构建时：  类型在类似 DSL 的“配方”标头中描述一次 生成器发出描述字段名称、类型、偏移量、限定符等的静态元数据。  在运行时：  实例被包装在轻量级反射句柄中 通用代码迭代元数据以统一检查或操作字段  重要的约束是不会发生运行时类型发现。所有信息在编译时都是已知的，并以纯 C 数据结构的形式发出。 为什么这在 C 中很有趣 没有模板或泛型，C 代码通常将逻辑与类型结合起来。例如，JSON 序列化通常会变成：  每个结构一个函数 或者发出完整序列化器的大型代码生成步骤  通过仅生成元数据，通用逻辑（JSON、二进制编码、验证、比较等）可以驻留在一个地方并适用于许多不相关的结构！这会将代码生成从行为转变为描述。 最小示例：通用 JSON stringify /* C 中的通用 JSON.stringify() */ static void json_stringify(const struct Reflectc_wrap *obj, char buf[], size_t bufsize) { /* 迭代字段，检查类型信息，发出 JSON */ }  在调用站点，不需要每种类型的序列化器： struct person alice = {“Alice”, 30, true, “alice@example.com”};结构reflectc*registry=reflectc_init(); struct Reflectc_wrap *w = Reflectc_from_person(registry, &amp;alice, NULL);字符 json[256]； json_stringify(w, json, sizeof json);  序列化器只能看到元数据+指针，而不是具体类型。 完整的工作实现可以在这里找到：https://github.com/lcsmuller/reflect-c/blob/master/test/runtime.c 设计约束和权衡 这种方法故意避免：  动态类型 ABI 自省 编译器插件或 AST 工具  作为交换，它需要：  生成元数据的构建步骤 通过配方标头显式选择加入  结果不是“真正的反射”，而是一种在 C 的约束范围内工作的务实的中间立场，并保持运行时代码简单和可重用。 何时这种模式有意义  REST API 规范包装器（我的主要用例） 协议或序列化层 验证和检查工具 类型定义稳定但逻辑不断发展的情况  这不是灵丹妙药，但它是重新思考 C 语言密集型代码库中实际需要多少重复的有趣方法。   由   提交 /u/LucasMull   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qluj9z/writing_a_generic_jsonstringify_that_serializes/</guid>
      <pubDate>Sat, 24 Jan 2026 18:23:28 GMT</pubDate>
    </item>
    <item>
      <title>RustyPP：一个 C++20 库和 Clang 工具，用于强制执行类似 Rust 的安全性和可变性。</title>
      <link>https://www.reddit.com/r/programming/comments/1qluakt/rustypp_a_c20_library_and_clang_tool_to_enforce/</link>
      <description><![CDATA[在这里找到源代码！：https://github.com/I-A-S/RustyPP 嘿伙计们 我最近开始学习 Rust，非常喜欢借用检查机制，更重要的是“默认情况下不可变”。方面（实际上还有更多方面）。 随着 Microsoft 将 Rust 放入 Windows 内核，Linus 批准将其用于 Linux 内核，让我们承认，Rust 正在成为对 C++ 的复仇者级别威胁。出于充分的原因，在当今时代，安全性和安全性变得越来越重要。 我的目标是推广（并使用 rustypp-validator 强制执行），将 Rust 的优点用于 C++。 以下是 RustyPP 目前提供的内容：  单个标头包含：rustypp.hpp（这为您提供了 Mut、Const、Ref、MutRef、Result 和基本可选选项）类型别名 u8、i32 等） rustypp-validator：这是一个独立的 C++ 编写的可执行文件，嵌入 clang 以强制执行“安全”验证。编码实践。 rustypp-vscode：VSCode 扩展，可在您输入时为您提供实时验证器检查  以下内容已计划但尚未提供：  CLion 扩展 RustyPP 转换器  RustyPP 仍然是 v0.1.0 顺便说一句，因此 API 不是最终版本，可能会发生变化（尽管如果收益大于成本，我只会添加重大更改） 我的希望是使 C++ 代码库更加安全（和标准化）。我喜欢 cpp，而不是让 Rust 成为我的日常驱动程序，我试图将 Rust 真正好的方面带到 cpp 中。 项目是在 Apache v2 下发布的。 欢迎任何和所有反馈！   由   提交/u/I-A-S-  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qluakt/rustypp_a_c20_library_and_clang_tool_to_enforce/</guid>
      <pubDate>Sat, 24 Jan 2026 18:14:38 GMT</pubDate>
    </item>
    <item>
      <title>嘿，我是一名全栈 Web 开发人员，我自己构建了几个全栈多功能项目，有人请告诉我如何获得 10,000 卢比的校外实习机会吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1qltoc4/hey_im_a_full_stack_web_developer_and_i_have/</link>
      <description><![CDATA[ 由   提交/u/davygamer18  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qltoc4/hey_im_a_full_stack_web_developer_and_i_have/</guid>
      <pubDate>Sat, 24 Jan 2026 17:52:07 GMT</pubDate>
    </item>
    <item>
      <title>对我的新作品集的反馈！！</title>
      <link>https://www.reddit.com/r/programming/comments/1qlthsh/feedback_on_my_new_portfolio/</link>
      <description><![CDATA[..   由   提交/u/davygamer18  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlthsh/feedback_on_my_new_portfolio/</guid>
      <pubDate>Sat, 24 Jan 2026 17:45:24 GMT</pubDate>
    </item>
    <item>
      <title>初级 React 开发人员的工资是按小时计算的吗？我怎样才能轻松找到一个？</title>
      <link>https://www.reddit.com/r/programming/comments/1qltdui/junior_react_developer_salary_rate_hourly_based/</link>
      <description><![CDATA[对于经验不足一年的初级 React 开发人员。 对于这种相关项目或工作，我可以以全职或承包商的身份开始收费多少？ 我想根据开发职业年龄了解你的薪水。   由   提交 /u/Flashy_Roof3908   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qltdui/junior_react_developer_salary_rate_hourly_based/</guid>
      <pubDate>Sat, 24 Jan 2026 17:41:25 GMT</pubDate>
    </item>
    <item>
      <title>google在浏览器级别满足使用什么样的RPC？</title>
      <link>https://www.reddit.com/r/programming/comments/1qltayt/what_kind_of_rpc_does_google_meet_use_at_the/</link>
      <description><![CDATA[我很好奇 google meet 应用程序从浏览器进行的网络调用是什么，并遇到了对 /$rpc/google.rtc.meetings.v1.MeetingSpaceService/SyncMeetingSpaceCollections 的网络调用，其内容类型为 x-protobuf。任何人都知道这是什么类型的远程过程调用。是 gRPC-web 还是仅在 Google 内部使用的自定义版本？   由   提交 /u/CaptainCodeKe   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qltayt/what_kind_of_rpc_does_google_meet_use_at_the/</guid>
      <pubDate>Sat, 24 Jan 2026 17:38:31 GMT</pubDate>
    </item>
    <item>
      <title>电子纸笔记本电脑的抖动</title>
      <link>https://www.reddit.com/r/programming/comments/1qlowl6/dithering_for_an_epaper_laptop/</link>
      <description><![CDATA[ 由   提交/u/PMunch   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlowl6/dithering_for_an_epaper_laptop/</guid>
      <pubDate>Sat, 24 Jan 2026 14:50:48 GMT</pubDate>
    </item>
    <item>
      <title>啊，SEO 不再一样了，谷歌没有列出它们？</title>
      <link>https://www.reddit.com/r/programming/comments/1qlo3rx/ahh_seo_no_longer_same_anymore_google_not_listing/</link>
      <description><![CDATA[]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlo3rx/ahh_seo_no_longer_same_anymore_google_not_listing/</guid>
      <pubDate>Sat, 24 Jan 2026 14:16:43 GMT</pubDate>
    </item>
    <item>
      <title>我开始将决定具体化，然后在做出承诺之前把它们写下来，这样我的大脑就可以不再把它们放在后台。很好奇这里的其他人是否做了类似的事情，或者您是否找到了另一种减少认知负荷的方法。</title>
      <link>https://www.reddit.com/r/programming/comments/1qlnwqm/i_started_externalizing_decisions_writing_them/</link>
      <description><![CDATA[ 由   提交/u/Available_Witness808  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlnwqm/i_started_externalizing_decisions_writing_them/</guid>
      <pubDate>Sat, 24 Jan 2026 14:08:37 GMT</pubDate>
    </item>
    <item>
      <title>作为软件工程师最被低估的技能</title>
      <link>https://www.reddit.com/r/programming/comments/1qlnujp/most_underrated_skill_as_a_software_engineer/</link>
      <description><![CDATA[代码定位是通过有效利用环境功能来导航代码库的技巧。它是关于使用搜索来移动文件、文件夹、符号和引用，以准确到达您需要的位置。它是关于了解您的环境、它如何运作以及如何让环境为您服务。它是关于使用正确的工具，这些工具可以减轻精神压力并帮助您构建解决问题的背景。  面向代码是一门手艺，而且你可以真正擅长。然而，它很少被提及，而且是一些工程师从未做过的投资 - 但我认为这是软件工程师可以拥有的最被低估的技能之一。 掌握代码方向就像弹钢琴，如果演奏得好 - 它看起来简单、优雅和美丽。你可以看到钢琴家如何在琴键上流动，将和弦编织在一起，并充分利用钢琴，创造出美丽的东西。 就像钢琴家使用钢琴一样，工程师将其和弦编成一首由代码块从一个地方移动到另一个地方、文件打开和关闭、视觉突出显示、文件创建、模糊搜索、LSP 引用 - 光标跳跃段落和单词的交响乐。 我过去常常在询问更高级的人时思考向同事求助——这些人只是比我聪明还是有别的原因？我可以看出，当我尝试一种解决方案时，他们已经尝试了三种解决方案。他们了解自己的环境 - 何时使用搜索、何时利用 LSP 查找引用、如何在代码块之间跳转、如何在代码和终端输出之间移动而不丢失上下文。  从那时起，我了解到代码导向是一种技能。 在代码导向中，速度并不是最重要的部分 - 速度是副产品。真正重要的是构建上下文所需的能量。以有效的方式构建这种环境是重要的部分。凭借强大的方向性，您可以节省精力、保持控制并准确地知道如何有效地浏览代码库。目标是使导航成本尽可能低，同时仍然产生强大的结果。 这就是缺乏代码导向开始变得重要的地方。如果没有它，程序员的进步自然就会有上限。您可以编写良好的代码、理解各个组件并解决明确定义的问题，但随着系统的增长，导航的认知成本变得难以承受。当太多的精力花在寻找合适的工作地点上时，用于推理、设计和解决问题的能力就会减少。在这一点上，复杂性不仅会减慢你的速度，还会限制你实际能够达到的掌握程度。 能够自由地浏览代码库并快速构建上下文，使你能够检查系统，而不会消耗不必要的精力。 如果做得好，代码导向看起来很优雅，听起来很漂亮，而且感觉很简单。但当它缺失时，一切都会感觉比应有的更重。纸上看起来简单的任务在实践中变得令人筋疲力尽，不是因为问题本身很难，而是因为构建上下文感觉如此沉重。 对我来说，代码导向不仅仅是另一项有用的技能 - 它是软件工程中最被低估的技能，也是长期有效性的最大乘数之一。   由   提交 /u/Cool-Reindeer-3946   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlnujp/most_underrated_skill_as_a_software_engineer/</guid>
      <pubDate>Sat, 24 Jan 2026 14:06:07 GMT</pubDate>
    </item>
    <item>
      <title>面向 Java 程序员的 Rust 迭代器和闭包</title>
      <link>https://www.reddit.com/r/programming/comments/1qlmhxa/rust_iterators_and_closures_for_java_programmers/</link>
      <description><![CDATA[了解 Rust 的迭代器与 Java Streams 的比较，以及为什么闭包比 lambda 更强大。 关键见解： - 闭包语法和三个闭包特征（Fn、FnMut、FnOnce） - 迭代器方法（map、filter、fold 等） - 惰性求值和零成本抽象 - 比较 Java 和 Rust 的实际例子   由   提交 /u/MasterOntology   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qlmhxa/rust_iterators_and_closures_for_java_programmers/</guid>
      <pubDate>Sat, 24 Jan 2026 13:06:11 GMT</pubDate>
    </item>
    <item>
      <title>无论您何时何地需要，与经验丰富的专业人士联系以获得指导、指导或完成任务。</title>
      <link>https://www.reddit.com/r/programming/comments/1qllt2s/connect_with_seasoned_pros_for_instruction/</link>
      <description><![CDATA[ 由   提交/u/No-Consequence-4156   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qllt2s/connect_with_seasoned_pros_for_instruction/</guid>
      <pubDate>Sat, 24 Jan 2026 12:31:27 GMT</pubDate>
    </item>
    <item>
      <title>jj 别名列表</title>
      <link>https://www.reddit.com/r/programming/comments/1qllm32/list_of_jj_aliases/</link>
      <description><![CDATA[我想了解大家最喜欢的 Jujutsu 别名，但找不到完整的列表。因此，我设置了一个名为 jj 别名列表（别名和 revset 别名）的简单页面。  任何人都可以添加别名并为其投票。您只需要一个 Github 帐户即可。  这有点笨拙，因为“存储”是在由 Github 讨论线程组成，但无需成为网络专家即可轻松设置。 :) 当前投票最高的别名是 tug，而 revset 别名尚未获得任何喜爱。   由   提交/u/thomasa88  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qllm32/list_of_jj_aliases/</guid>
      <pubDate>Sat, 24 Jan 2026 12:21:42 GMT</pubDate>
    </item>
    <item>
      <title>隔离克劳德代码</title>
      <link>https://www.reddit.com/r/programming/comments/1qljvjy/isolating_claude_code/</link>
      <description><![CDATA[ 由   提交/u/skwee357  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qljvjy/isolating_claude_code/</guid>
      <pubDate>Sat, 24 Jan 2026 10:42:12 GMT</pubDate>
    </item>
    <item>
      <title>我想开一家初创公司</title>
      <link>https://www.reddit.com/r/programming/comments/1qljo9k/хочу_открыть_стартап/</link>
      <description><![CDATA[我想为我的汽车制作一个人工智能语音助手，我可以为其添加哪些功能？   由   提交 /u/Pristine_Mirror_4052   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qljo9k/хочу_открыть_стартап/</guid>
      <pubDate>Sat, 24 Jan 2026 10:29:53 GMT</pubDate>
    </item>
    </channel>
</rss>
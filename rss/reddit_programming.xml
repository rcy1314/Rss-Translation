<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 18 Aug 2025 18:37:37 GMT</lastBuildDate>
    <item>
      <title>logmod：ANSI C中的模块化记录框架（无全球或隐藏的mallocs）</title>
      <link>https://www.reddit.com/r/programming/comments/1mtsvgr/logmod_a_modular_logging_framework_in_ansi_c/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   hey  r/programming ！！ 始终在C项目中困扰我的一件事：我可能会依靠隐藏的全局范围 我试图回答： logger既避免了 结果是什么样的？保持ANSI C且不会动态分配内存的记录库。以下是关键思想：   默认情况下没有全球状态  - 您明确地通过日志记录上下文； if you’re lazy, there’s still a fallback logger that kicks in when you pass NULL. Zero dynamic allocation – you pre‑allocate a table of logger structs and hand that to logmod_init. Works in both C89 and C99 – variadic macros for C99 and a tuple‑style logmod_nlog for old compilers. Custom labels and colours – define your own log levels starting from LOGMOD_LEVEL_CUSTOM, register them via logmod_logger_set_callback, and optionally colourise output. Thread‑safety and callbacks – supply a custom lock function for multi‑threaded logging, and hook into the logging pipeline to augment or filter messages. Configurable options – toggle console output, set a logfile, enable colours, or decide whether to show the application/context IDs.  Examples  不带全球的初始化：    #include; logmod.h; struct logmod logmod; struct logmod_logger表[4]; // PRE -OLACTARE LOGMOD_INIT（＆amp; logMod，&#39;app＆quot＆quot＆quot，table，4）; struct logmod_logger *net = logmod_get_logger（＆amp; logmod，&#39;&#39;network; quot＆quot; logmod_log（info，net，“连接到服务器％s＆quot”，主机）;    使用后式记录器（可选）：     logmod_log（warn，null，null，; quot&#39;nto config config confiend confiend confiend confiend confiend confiend confience offient offions; quote; quote; //使用内置的后备   定义自定义标签和颜色：     enum {logmod_level_http = logmod_level_level_custom，logmod_level_test};静态常规struct logmod_label custy_labels [] = {{{＆quot; http; logmod_label_color（常规，前景，蓝色），0}，{; void my_callback(const struct logmod_logger *logger, const struct logmod_info *info, const char *fmt, va_list args) { // custom handling... // return LOGMOD_OK to suppress default logging, or LOGMOD_OK_CONTINUE to augment } size_t num_labels = sizeof(custom_labels) / sizeof *custom_labels; logmod_logger_set_callback（net，custom_labels，num_labels，my_callback）; logmod_log（收到的http，net，net，net，http请求：％s＆quort; url）; logmod_log（在测试模式下运行测试，net，&#39;）;    切换颜色并设置logfile：     struct logmod_options opts opts = {.logfile = fopen（app.log; logmod_set_options（＆amp; logmod，opts）; //所有记录器logmod_logger_set_color的默认值（net，0）; //禁用此  外卖 挑战是使其便于携带和符合ANSI -C的挑战，同时避免了全球状态和隐藏的分配。它变成了几百行代码，但刮擦了特定的瘙痒。如果您喜欢挖掘低级设计交易，您可能会发现它很有趣。如果您需要JSON记录或远程接收器，不是。提交由＆＃32; /u/u/lucasmull      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtsvgr/logmod_a_modular_logging_framework_in_ansi_c/</guid>
      <pubDate>Mon, 18 Aug 2025 17:39:06 GMT</pubDate>
    </item>
    <item>
      <title>第41天：如何像专业人士一样保护您的node.js应用</title>
      <link>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/myssiriouseye8494     [link]   ＆＃32;  &lt;a href =“ https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_to_secure_your_your_your_nodejs_app_app_app_app_a _a_a_a_a_pro/]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</guid>
      <pubDate>Mon, 18 Aug 2025 15:34:59 GMT</pubDate>
    </item>
    <item>
      <title>默认情况下不变：如何避免OOP中隐藏的状态错误</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/backendtea      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</guid>
      <pubDate>Mon, 18 Aug 2025 13:28:50 GMT</pubDate>
    </item>
    <item>
      <title>汇编不仅用于编程语言</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/Adventurous-salt8514      [link]  ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</guid>
      <pubDate>Mon, 18 Aug 2025 13:26:39 GMT</pubDate>
    </item>
    <item>
      <title>为快乐而建立不仅仅是为了工作</title>
      <link>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  如何通过激情构建工艺  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/livid_sign9681      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</guid>
      <pubDate>Mon, 18 Aug 2025 13:08:13 GMT</pubDate>
    </item>
    <item>
      <title>使不可能的状态不可能：使用功能依赖注入的类型安全域建模</title>
      <link>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/cekrem      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</guid>
      <pubDate>Mon, 18 Aug 2025 12:40:40 GMT</pubDate>
    </item>
    <item>
      <title>员工+佳能：无权领导工具</title>
      <link>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/bezomaxo      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</guid>
      <pubDate>Mon, 18 Aug 2025 12:23:02 GMT</pubDate>
    </item>
    <item>
      <title>让我们做游戏吧！ 307：战场边界</title>
      <link>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/apeloverage      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</guid>
      <pubDate>Mon, 18 Aug 2025 11:00:40 GMT</pubDate>
    </item>
    <item>
      <title>2025年基准前端</title>
      <link>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</link>
      <description><![CDATA[Hey r/programming, For a while now, I&#39;ve felt that our standard frontend benchmarks don&#39;t tell the whole story for the kind of complex, data-heavy apps many of us spend our days building.核心Web Vitals非常适合初始负载，并且流行的 JS-FrameWork-benchmark 很有用，但是它在测试时尺度应用程序中有两个主要限制：它禁止虚拟化/缓冲渲染，并且在造成沉重的背景时，它在造成的    &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  &gt; &gt; &gt; 。 我们的应用程序的弹性。 为了解决这个问题，我在过去的10天里花了一个新的基准测试标准，从而使用剧作家从头开始。目的是创建可以在持续的，同时进行的胁迫下提供可靠，高精度测量的东西。 构建这本身就是一个严肃的工程挑战，我想分享三个关键的经验教训：      是平行的trap：我的第一个本能是我的第一个本能是运行测试。这是一场灾难。最大化浏览器实例之间的CPU争论使结果偏向50％。 Lesson: Accurate performance benchmarking must be run serially (--workers=1). The Latency Chasm: The back-and-forth between the Node.js test runner and the browser introduced too much noise. 课程：测量必须是原子。我必须在单个 page.evaluate（）呼叫中包裹整个测试逻辑（触发操作 - 触发动作 - 等待条件 - 测量时间）  waitfor 函数（像大多数）使用长抽纸，这不足以进行性能测量。您无法使用30ms的轮询间隔测量20ms事件。 课程：不信任投票。我必须使用 mutationObserver 在 Exccent 时刻停止计时器。我创建的框架（neo.mjs）。我声称，从主线程中卸载逻辑可以解决主要的性能瓶颈，社区正确地要求提供证明。该基准是证明。  结果  到目前为止，最有趣的测试是针对行业领先的AG网格的新的Neo.mjs网格（在React App中）。当执行重型操作（例如将视口从50列调整为100,000行）时，结果鲜明：      react + ag react + ag grid： 〜3,000-5,5,500ms UI更新时间。       neo.mjs：   〜400ms Ui time。性能差异，取决于浏览器。 这不是对AG网格的起诉，这是一件很棒的工程。这是一个有力的数据点，显示了一个单线读取范式施加的建筑天花板。即使是一流的组件，最终也受到阻塞的主线程的限制。 这是一个开源项目，我希望开始就我们如何更好地衡量和构建“居住在”中的对话。网络。我很想获得有关方法和结果的反馈。   全文（“为什么”）：  https://tobiasuhlig.medium.com/benchmarking-frontends-in-2025-f6bbf43b7721?source=friends = friends_links_link＆amp; sk = af0f2c6745a7ca49999993bc0ae60ae60ae60ae60AdAdaebb40ebb4   github repo（“如何”  - 代码，方法论，结果）：  https://github.com/neomjs/neomjs/neomjs/neomjs/benchmarks/benchmarks  href =“ https://neomjs.com/dist/production/examples/grid/bigdata/index.html“  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tobiasuhlig      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</guid>
      <pubDate>Mon, 18 Aug 2025 10:16:25 GMT</pubDate>
    </item>
    <item>
      <title>LLM测试策略，来自OpenAI，Google，拟人化，Meta</title>
      <link>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/azilentech      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</guid>
      <pubDate>Mon, 18 Aug 2025 10:13:53 GMT</pubDate>
    </item>
    <item>
      <title>内容 - 可调的存储（CAS）</title>
      <link>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/vannam0511      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</guid>
      <pubDate>Mon, 18 Aug 2025 08:28:53 GMT</pubDate>
    </item>
    <item>
      <title>NUMA是新网络：每个插座内存模型如何重塑微服务放置</title>
      <link>https://www.reddit.com/r/programming/comments/1mt8qjj/numa_is_the_new_network_how_persocket_memory/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  探讨非统一内存访问（numa）如何重塑微服务放置。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/mqian41     [link]   [commist]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mt8qjj/numa_is_the_new_network_how_persocket_memory/</guid>
      <pubDate>Mon, 18 Aug 2025 01:34:23 GMT</pubDate>
    </item>
    <item>
      <title>记录代码很无聊...。但是不一定是</title>
      <link>https://www.reddit.com/r/programming/comments/1mt6zy1/documenting_code_is_boring_but_it_doesnt_have_to/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  本文让我思考了我们行业中的基本悖论 - 我们都迫切需要良好的文档，但我们大多数人都讨厌创建它。该文章谈到了通过更好的设计和结构使文档“减少无聊”，但是我对基本问题更加好奇：写文档的痛苦实际上值得解决，还是大多数开发人员只是接受它是必要的邪恶？以我的经验，大约有三个营地：1。受害者 - 撰写文档，因为他们必须恨它2。您是：•通过乏味的乏味，因为您知道这很重要吗？ •使用任何工具/自动化来减轻痛苦？ •只是……除非绝对强迫，否则不这样做？我特别感兴趣的是人们认为这是一个值得通过更好的工具解决的问题，还是只是我们需要接受的开发的固有部分。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/ok-ok-ad7050     splass &lt;56fba&gt;  ＆＃32;   [注释]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mt6zy1/documenting_code_is_boring_but_it_doesnt_have_to/</guid>
      <pubDate>Mon, 18 Aug 2025 00:12:49 GMT</pubDate>
    </item>
    <item>
      <title>自定义LISP REPL</title>
      <link>https://www.reddit.com/r/programming/comments/1mt5886/customizing_lisp_repls/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/aartaka      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mt5886/customizing_lisp_repls/</guid>
      <pubDate>Sun, 17 Aug 2025 22:53:16 GMT</pubDate>
    </item>
    <item>
      <title>固定靴子，TPM和反陈词发动机</title>
      <link>https://www.reddit.com/r/programming/comments/1mt05nb/secure_boot_tpm_and_anticheat_engines/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/tapo      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mt05nb/secure_boot_tpm_and_anticheat_engines/</guid>
      <pubDate>Sun, 17 Aug 2025 19:28:52 GMT</pubDate>
    </item>
    </channel>
</rss>
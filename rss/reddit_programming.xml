<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sat, 03 Jan 2026 12:50:16 GMT</lastBuildDate>
    <item>
      <title>用 Rust 编写的高性能嵌入式矢量数据库</title>
      <link>https://www.reddit.com/r/programming/comments/1q2tsf8/a_high_performance_embedded_vector_database/</link>
      <description><![CDATA[嗨，我创建了 SatoriDB，它是一个两层搜索系统：一个小型“热门”搜索系统RAM 中的索引将查询路由到“冷”索引磁盘上的矢量数据。这使我们能够处理数十亿规模的数据集，而无需将所有内容保存在内存中。 很想听听您对架构的想法   由   提交/u/Ok_Marionberry8922   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2tsf8/a_high_performance_embedded_vector_database/</guid>
      <pubDate>Sat, 03 Jan 2026 12:47:07 GMT</pubDate>
    </item>
    <item>
      <title>[FOSS] 我如何基于光传感器自动化 Android 黑暗模式</title>
      <link>https://www.reddit.com/r/programming/comments/1q2tm1y/foss_how_i_automated_android_dark_mode_based_on/</link>
      <description><![CDATA[新年快乐！ 我可以出席吗？我最新的开源副项目、挑战和经验教训： 大多数 Android 暗模式自动化都与静态时钟或日落/日出时间表相关。我想构建一些更具情境感知能力的系统，即通过环境光传感器对物理环境做出反应的系统，而不会产生与背景传感器轮询相关的典型电池损耗。 以下是自适应主题背后的技术挑战和架构的详细说明。 1.挑战：实现“零”电池耗尽 监控环境光的标准方法涉及后台服务不断轮询SensorManager。这是一个电池杀手。 为了解决这个问题，我实现了一个事件驱动架构：  被动监控：应用程序不是前台服务，而是为 SCREEN_ON 意图注册一个 BroadcastReceiver。 分秒初始化：应用程序初始化SensorManager 仅在屏幕打开后立即出现一个简短的窗口，以验证勒克斯级别。 立即拆卸：一旦获得稳定的读数并切换主题（如有必要），传感器将立即取消注册。这样，当用户与设备交互时，主题不会切换。  这可确保在设备使用或屏幕关闭时后台 CPU 或传感器使用率为零。 2.技术限制：Android 14 和接收器上下文 开发过程中的一个有趣发现是，这种特定的事件驱动方法仅在 Android 14 (API 34) 及更高版本上可靠。 在旧版本的操作系统上，无法在该特定用例的广播接收器上下文的短执行窗口内正确初始化或读取光传感器。或者至少我没有找到解决方案。以 API 34 为目标，可以通过 Kotlin Flows 实现更稳定的反应流。 3.安全障碍：WRITE_SECURE_SETTINGS Android（理所应当）保护系统级 UI 设置。以编程方式更改系统主题需要 WRITE_SECURE_SETTINGS 权限，该权限无法通过标准清单提示授予。 为了在不需要 root 的情况下保持良好的用户体验，我必须实现几个替代的权限授予流程：  Shizuku 集成： 利用 Shizuku API 充当特权命令。 WebADB (WebUSB)：我使用 WebUSB API 在 lexip.dev/setup 构建了一个配套浏览器工具，以便用户可以从其他设备授予权限，而无需在本地安装 Android SDK 或 ADB。我很快就会推送它的源代码。 Root Fallback：一个简单的 su 命令，适用于已经拥有 root 环境的用户。  4.建筑与技术堆栈 该应用建立在现代反应式堆栈上，以确保可维护性：  UI： 使用 Material 3（Material You）的 100% Jetpack Compose。 状态管理： ViewModel 通过 Kotlin Flows 公开数据，并使用协程管理并发。 持久性：我放弃了 SharedPreferences，转而使用 Jetpack DataStore 进行类型安全的异步设置存储。 构建风格：为了在 Play 商店中保持 FOSS 兼容，我维护了一个基于风格的构建系统，该系统完全剥离了 GitHub/F-Droid 版本的专有 blob（例如 Firebase）。  经验教训 构建“简单”的应用程序实用程序告诉我，最难的部分不是核心逻辑（读取传感器），而是管理 Android 电源管理和安全策略的边缘情况。还有具有特殊权限的设置过程的用户体验。 我很想听听其他 Android 开发人员的意见：您是否找到了在旧 API 级别上读取 BroadcastReceiver 中的传感器的更可靠方法，或者迁移到 API 34+ 是唯一干净的前进道路？ 如果您遇到任何错误或对新功能有想法，请告诉我。我会随时回答任何问题！   由   提交 /u/xLexip   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2tm1y/foss_how_i_automated_android_dark_mode_based_on/</guid>
      <pubDate>Sat, 03 Jan 2026 12:37:43 GMT</pubDate>
    </item>
    <item>
      <title>您如何使用人工智能/编程来为自己解决现实世界的问题？</title>
      <link>https://www.reddit.com/r/programming/comments/1q2t88k/how_are_you_using_aiprogramming_to_solve_real/</link>
      <description><![CDATA[和标题差不多   由   提交/u/Wild_Operation_1929   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2t88k/how_are_you_using_aiprogramming_to_solve_real/</guid>
      <pubDate>Sat, 03 Jan 2026 12:16:40 GMT</pubDate>
    </item>
    <item>
      <title>以单一文本格式封装音频元数据和编辑逻辑</title>
      <link>https://www.reddit.com/r/programming/comments/1q2rvgs/encapsulating_audio_metadata_and_edit_logic_in_a/</link>
      <description><![CDATA[CUE 表描述了音频时间戳和元数据，但我想要更具表现力的东西。我构建了一个基于 CUE 的文本格式和一个具有类似 SQL 方法的工具，使其小巧且易于实现，同时允许简单但有效的编辑。 在演示中，仅使用 MP3 拖动和播放即可创建专辑混合曲。拖放和文本复制/粘贴—无需波形编辑。   由   提交 /u/cutandjoin   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2rvgs/encapsulating_audio_metadata_and_edit_logic_in_a/</guid>
      <pubDate>Sat, 03 Jan 2026 10:58:15 GMT</pubDate>
    </item>
    <item>
      <title>新的数据序列化工具</title>
      <link>https://www.reddit.com/r/programming/comments/1q2r639/new_data_serialization_tool/</link>
      <description><![CDATA[这是我发现的一个工具，看起来很酷！   由   提交 /u/uservydm   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2r639/new_data_serialization_tool/</guid>
      <pubDate>Sat, 03 Jan 2026 10:15:21 GMT</pubDate>
    </item>
    <item>
      <title>为什么开发人员的专业知识在人工智能时代比以往任何时候都更加重要</title>
      <link>https://www.reddit.com/r/programming/comments/1q2qa5m/why_developer_expertise_matters_more_than_ever_in/</link>
      <description><![CDATA[阅读“为什么开发人员的专业知识在人工智能时代比以往任何时候都更加重要”    由   提交/u/iammidhul  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2qa5m/why_developer_expertise_matters_more_than_ever_in/</guid>
      <pubDate>Sat, 03 Jan 2026 09:21:12 GMT</pubDate>
    </item>
    <item>
      <title>研究发现压痕深度与圈复杂度相关。一种与语言无关的测量代码复杂性的方法</title>
      <link>https://www.reddit.com/r/programming/comments/1q2q1ib/research_found_indentation_depth_correlates_with/</link>
      <description><![CDATA[ 由   提交/u/itaymendi   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2q1ib/research_found_indentation_depth_correlates_with/</guid>
      <pubDate>Sat, 03 Jan 2026 09:05:55 GMT</pubDate>
    </item>
    <item>
      <title>10 个可在几分钟内构建仪表板的 Python 库</title>
      <link>https://www.reddit.com/r/programming/comments/1q2pwq6/10_python_libraries_that_build_dashboards_in/</link>
      <description><![CDATA[ 由   提交 /u/Funny-Ad-5060   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2pwq6/10_python_libraries_that_build_dashboards_in/</guid>
      <pubDate>Sat, 03 Jan 2026 08:57:53 GMT</pubDate>
    </item>
    <item>
      <title>为什么大多数软件文档都失败了——以及可执行文档如何改变这一点</title>
      <link>https://www.reddit.com/r/programming/comments/1q2oo83/why_most_software_documentation_fails_and_how/</link>
      <description><![CDATA[ 由   提交 /u/Limp_Celery_5220   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2oo83/why_most_software_documentation_fails_and_how/</guid>
      <pubDate>Sat, 03 Jan 2026 07:43:05 GMT</pubDate>
    </item>
    <item>
      <title>Uber 如何实时显示数百万司机的位置</title>
      <link>https://www.reddit.com/r/programming/comments/1q2o00b/how_uber_shows_millions_of_drivers_location_in/</link>
      <description><![CDATA[ 由   提交/u/Sushant098123  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2o00b/how_uber_shows_millions_of_drivers_location_in/</guid>
      <pubDate>Sat, 03 Jan 2026 07:04:12 GMT</pubDate>
    </item>
    <item>
      <title>vanilla PHP 中的零依赖性遗传学引擎：14 个基因座、性连锁遗传、10,000 多种表型组合</title>
      <link>https://www.reddit.com/r/programming/comments/1q2mw5y/zerodependency_genetics_engine_in_vanilla_php_14/</link>
      <description><![CDATA[ 由   提交/u/Mammoth-Promotion-10   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2mw5y/zerodependency_genetics_engine_in_vanilla_php_14/</guid>
      <pubDate>Sat, 03 Jan 2026 06:04:32 GMT</pubDate>
    </item>
    <item>
      <title>香草 PHP 中的零依赖性遗传学引擎：14 个基因座、性连锁遗传、10,000 多种表型组合的笛卡尔积</title>
      <link>https://www.reddit.com/r/programming/comments/1q2mpdb/zerodependency_genetics_engine_in_vanilla_php_14/</link>
      <description><![CDATA[为鸟类饲养者 (Agapornis Roseicollis) 构建遗传学计算器：  纯 PHP，无框架，无库 通过笛卡尔积计算 14 个独立位点 性别连锁遗传矩阵（ZZ/ZW 鸟类系统） Wright 近交系数谱系图上的递归 DFS 用于反向基因型估计的类贝叶斯推理引擎 通过分层优先级系统解析了 310 多种表型  数学很有趣 - Punnett 跨 14 个维度进行平方，然后折叠相同的表型。 演示： http://kanarazu-project.com/gene-forge/Rosy-faced-Lovebird/?lang=en GitHub： https://github.com/kanarazu-project/gene-forge 烤我的代码或询问有关架构的任何信息。   由   提交/u/Mammoth-Promotion-10   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2mpdb/zerodependency_genetics_engine_in_vanilla_php_14/</guid>
      <pubDate>Sat, 03 Jan 2026 05:54:28 GMT</pubDate>
    </item>
    <item>
      <title>计划、检查、验证、回顾：人工智能辅助编码框架</title>
      <link>https://www.reddit.com/r/programming/comments/1q2ldrq/plan_do_check_verify_retrospect_a_framework_for/</link>
      <description><![CDATA[在过去的一年里，我一直在使用多个模型（Anthropic、GLM）和工具（Bolt、Cursor、Cline、Claude Code）进行 AI 辅助编码。 经过多次尝试和错误，我有了一个稳定的框架、提示或提示模板、模型和工具，用于我的 AI 辅助编码。 我使用的框架不是新的，但是灵感来自 InfoQ 上的一篇文章（评论中的链接）。它被称为计划、检查、验证、回顾（PDCVR）框架。 在详细说明每个步骤之前，这是我当前的设置： * 工具：Claude Code * 模型：Z.ai 的 GLM 4.7 现在，让我详细说明该框架： * PLAN * 对于您计划执行的任何任务，您都从一个计划开始。您希望模型只计划而不创建任何代码 * 是的，Claude Code 有计划模式，但我更喜欢不在模式之间切换并使用提示来处理相同的情况  * 您需要一个提示来帮助创建一个极其详细的计划，该计划提供逐步执行计划和强制性代码库调查，以便它不会重新创建某些内容或破坏现有的某些内容 * 最重要的一点要记住的是 2 每次开始新任务时都专注于 **1 个单一目标** *除此之外，当您进行人工智能辅助编码时，**TDD 是最重要的方面**。因此，您需要有一个提示，告诉模型先执行红色阶段（失败的测试），然后执行绿色阶段（成功的测试）*对于每个提示，我都会告诉法学硕士计划并使用 TDD（即使是 DO 步骤）  DO  阅读上面创建的计划，如果不满意，请迭代 一旦您感到满意，就可以继续实施 您可以说“从第 1 步开始”或“继续步骤1”或“实施后续步骤”或“实施计划的步骤”  检查  这一步非常重要，因为有时，LLM 可能不记得他们需要实施的后续步骤，并且会在不实施后续步骤的情况下完成工作 因此，您需要进行完整性检查，以确保 LLM 检查和评估是否一切都已实施并且正确，如果不是，那么它将告诉您接下来的步骤或剩余步骤  验证  此步骤与检查相同，但在这一步中，我调用克劳德代码代理，构建验证以确保所有内容都成功编译，并验证所有内容是否都作为任务的一部分实现  回顾  无论提示多么细致漂亮，无论模型多么智能，无论在SWE Bench编码中排名多么靠前，LLM都难免会犯错误 在这种情况下，你需要要求LLM对当前正在做的任务进行回顾，以便下次记录文档并记住所学内容  https://www.infoq.com/articles/PDCA-AI-code- Generation/?topicPageSponsorship=cb9cfb95-79e8-442a-8f4b-72cfb3789778 ：本文所基于的原始框架 https://arxiv.org/pdf/2312.04687：证明TDD非常重要并且是LLM所必需的论文 https://github.com/nilukush/plan-do-check-verify-retrospect/tree/master/prompts-templates：您将找到用于编码的通用提示模板，其中始终包含计划提示，这意味着您发送给LLM的每个提示，计划提示始终是通用提示模板的一部分  此外，它还有CHECK（完整性检查）和RETROSPECT的提示  https://github.com/nilukush/plan-do-check-verify-retrospect/tree/master/claude-code-subagents-for-coding 包含我在 Claude Code 中用于编码的所有子代理。您只需将其复制粘贴到 .claude/agents  它包括从 Orchestrator、产品经理到 DevOps 的代理，包括调试器、分析器和通用执行器子代理     由   提交 /u/nilukush   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2ldrq/plan_do_check_verify_retrospect_a_framework_for/</guid>
      <pubDate>Sat, 03 Jan 2026 04:47:38 GMT</pubDate>
    </item>
    <item>
      <title>可延展的软件：在锁定应用程序的世界中恢复用户代理</title>
      <link>https://www.reddit.com/r/programming/comments/1q2kz3k/malleable_software_restoring_user_agency_in_a/</link>
      <description><![CDATA[ 由   提交/u/misterolupo  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2kz3k/malleable_software_restoring_user_agency_in_a/</guid>
      <pubDate>Sat, 03 Jan 2026 04:27:50 GMT</pubDate>
    </item>
    <item>
      <title>经验证的基于模型的傻瓜一致性测试</title>
      <link>https://www.reddit.com/r/programming/comments/1q2k9dl/verified_modelbased_conformance_testing_for/</link>
      <description><![CDATA[ 由   提交/u/DrJimmyBrungus_   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q2k9dl/verified_modelbased_conformance_testing_for/</guid>
      <pubDate>Sat, 03 Jan 2026 03:53:37 GMT</pubDate>
    </item>
    </channel>
</rss>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Tue, 28 Oct 2025 21:24:31 GMT</lastBuildDate>
    <item>
      <title>了解 Docker 内部结构：用 Python 构建容器运行时</title>
      <link>https://www.reddit.com/r/programming/comments/1oiliw9/understanding_docker_internals_building_a/</link>
      <description><![CDATA[ 由   提交/u/mraza007  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oiliw9/understanding_docker_internals_building_a/</guid>
      <pubDate>Tue, 28 Oct 2025 21:07:57 GMT</pubDate>
    </item>
    <item>
      <title>高级代理事务</title>
      <link>https://www.reddit.com/r/programming/comments/1oii7ab/high_agency_matters/</link>
      <description><![CDATA[ 由   提交/u/feross  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oii7ab/high_agency_matters/</guid>
      <pubDate>Tue, 28 Oct 2025 19:01:41 GMT</pubDate>
    </item>
    <item>
      <title>“氛围验证”算法带来的惊喜</title>
      <link>https://www.reddit.com/r/programming/comments/1oihhbi/surprises_from_vibe_validating_an_algorithm/</link>
      <description><![CDATA[“形式验证”正在创建一个数学证明，证明程序可以实现您想要的功能。这是出了名的困难和昂贵。 （如果它简单且便宜，我们也许可以用来验证一些人工智能生成的代码。） 上个月，我使用 ChatGPT-5 和 Codex（以及 Claude Sonnet 4.5）来验证 Rust 库中的（手写）算法。人工智能工具生成了证据，并由名为 Lean 的校对人员进行了检查。链接到下面的完整详细信息，但令我惊讶的是：  它有效。在人工智能的帮助下，在不了解精益形式方法的情况下，我验证了精益中的数据结构算法。 项目进行到一半时，Codex 和 Claude Sonnet 4.5 相继发布。我可以感受到这些版本的智力飞跃。 开始这个项目时，我无法阅读精益，但在人工智能的帮助下，我学到了足够的知识来审核证明的关键顶层。事实证明，阅读水平的掌握就是我所需要的。 证据是巨大的，大​​约 4,700 行 Lean 只用了 50 行 Rust。两年前，Divyanshu Ranjan 和我用 357 行 Dafny 验证了相同的算法。 然而，与依赖于随机 SMT 搜索的 Dafny 不同，Lean 构建了明确的逐步证明。 Dafny 可能会将某些内容标记为已证明，但相同的验证可能在另一次运行中失败。当精益证明某件事时，它就会一直被证明。 （任一工具的失败并不意味着该命题是错误的 - 只是当时无法验证它。） AI 试图愚弄我两次，一次是通过 set_option 隐藏抱歉，另一次是提出公理而不是证明。 验证过程比我预期的工作量更大，成本更高。这需要几周的兼职工作和大约 50 美元的人工智能积分。 这个过程仍然容易出错。如果我未能正确审核算法对精益的翻译，最终可能会证明是错误的。幸运的是，有两个项目已经在解决这个翻译问题：针对 Coq 的 coq-of-rust 和针对 Lean 的 Aeneas。这些最终可能会消除手动或人工智能辅助移植的需要。之后，我们只需要人工智能自己编写经过精益验证的证明，这看起来不仅是可能的，而且是实用的。 元提示效果很好。就我而言，我元提示了基于浏览器的 ChatGPT-5。也就是说，我要求它为 AI 编码代理 Claude 和 Codex 编写提示。由于当前人工智能定价的怪癖，这种方法也有助于降低成本。 所得的证明几乎肯定是不必要的冗长。我很乐意为精益算法验证库做出贡献，但我担心这些 Vibe 风格的证明过于草率且一次性，无法作为未来证明的构建块。  要点 Vibe 验证仍然是一头跳舞的猪。令人惊奇的不是它跳舞有多优雅，而是它真的在跳舞。不过我很乐观。长期以来，传统观点认为算法的形式验证太难且成本太高，不值得。但有了精益和人工智能代理等工具，成本和工作量都在快速下降。我相信形式验证将在未来的软件开发中发挥更大的作用。 使用 Lean、ChatGPT-5 和 Vibe 进行 Vibe 验证克劳德 4.5   由   提交 /u/carlk22   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oihhbi/surprises_from_vibe_validating_an_algorithm/</guid>
      <pubDate>Tue, 28 Oct 2025 18:34:23 GMT</pubDate>
    </item>
    <item>
      <title>打字俱乐部 - 通过搏击俱乐部的视角了解打字</title>
      <link>https://www.reddit.com/r/programming/comments/1oiertg/type_club_understanding_typing_through_the_lens/</link>
      <description><![CDATA[ 由   提交/u/AltruisticPrimary34  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oiertg/type_club_understanding_typing_through_the_lens/</guid>
      <pubDate>Tue, 28 Oct 2025 16:54:05 GMT</pubDate>
    </item>
    <item>
      <title>ArkRegex 简介：用类型替换 new RegExp()</title>
      <link>https://www.reddit.com/r/programming/comments/1oie1nq/introducing_arkregex_a_drop_in_replacement_for/</link>
      <description><![CDATA[ 由   提交 /u/ssalbdivad   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oie1nq/introducing_arkregex_a_drop_in_replacement_for/</guid>
      <pubDate>Tue, 28 Oct 2025 16:27:26 GMT</pubDate>
    </item>
    <item>
      <title>Patreon 扩展现场活动的经验教训：流量建模、性能调整和团队协调</title>
      <link>https://www.reddit.com/r/programming/comments/1oicq3e/lessons_from_scaling_live_events_at_patreon/</link>
      <description><![CDATA[在 Patreon，我们最近扩展了我们的平台，可以同时处理数万名粉丝参加现场活动。通过对真实用户到达情况进行建模、调整性能以及跨团队协调，我们将 Web 加载时间缩短了 57%，并将 iOS 启动请求减少了一半。 以下是我们的做法以及我们在突发负载下扩展实时系统方面学到的知识： https://www.patreon.com/posts/from-thundering-141679975 您从扩展自己工作过的平台中学到了哪些令人惊讶的经验教训？   由   提交/u/patreon-eng   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oicq3e/lessons_from_scaling_live_events_at_patreon/</guid>
      <pubDate>Tue, 28 Oct 2025 15:38:55 GMT</pubDate>
    </item>
    <item>
      <title>在生产中调试 LLM 应用程序比预期更难</title>
      <link>https://www.reddit.com/r/programming/comments/1oia68m/debugging_llm_apps_in_production_was_harder_than/</link>
      <description><![CDATA[我一直在运行一个带有 RAG 检索、代理链和工具调用的 AI 应用程序。最近，一些用户开始报告响应速度缓慢，并且偶尔会出现错误的答案。 问题是我无法判断哪个部分损坏了。矢量搜索？提示？代币限制？基本上是在各处添加打印语句，并希望在日志中显示一些内容。 APM 工具为我提供了 API 延迟和错误率，但对于我需要的 LLM 内容：  从向量数据库中检索了哪些文档 预处理后的实际提示 令牌使用细分 瓶颈在哪里 chain  我的解决方案： 设置 Langfuse（开源、自托管）。使用 Postgres、Clickhouse、Redis 和 S3。 Web 和工作容器。 observe() 装饰器跟踪管道。显示：  完整请求流程 模板化后提示 检索上下文 每个请求的令牌使用 逐步延迟  部署 最初使用其 Docker Compose 设置。对于较小的规模效果很好。他们有 Kubernetes 扩展指南。 文档 网关设置 添加 AnannasAI 作为 LLM 网关。具有自动故障转移功能的多个提供商的单一 API。在混合不同模型源时对于混合设置很有用。 Anannas 处理网关指标，Langfuse 处理应用程序跟踪。提供跨两个层的可见性。 实现文档 捕获了什么 矢量搜索返回错误块 - 嵌入缓存无法正常工作。跟踪显示了实际检索到的内容，以便我可以看到问题。 一些提示达到了上下文限制并被截断。解释了奇怪的输出。 Stack  Langfuse（Docker，自托管） Anannas AI（网关） Redis、Postgres、Clickhouse  跟踪数据由于是自托管而保留在本地。 如果有人正在调试类似的内容 对于第一次参加 LLM 问题，可能会有用。   由   提交/u/Silent_Employment966   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oia68m/debugging_llm_apps_in_production_was_harder_than/</guid>
      <pubDate>Tue, 28 Oct 2025 14:00:56 GMT</pubDate>
    </item>
    <item>
      <title>刚刚发表了一篇关于我认为振动编码和语音编码的发展方向的文章</title>
      <link>https://www.reddit.com/r/programming/comments/1oia1op/just_published_an_article_on_where_i_think_vibe/</link>
      <description><![CDATA[分享我写的一篇文章（主要是通过语音），内容涉及振动编码、语音输入和人工智能辅助编程的未来。很想听听别人的想法或经历。   由   提交 /u/mikaelainalem   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oia1op/just_published_an_article_on_where_i_think_vibe/</guid>
      <pubDate>Tue, 28 Oct 2025 13:55:57 GMT</pubDate>
    </item>
    <item>
      <title>波士顿的 Anthony 的 Armaaruss 检测：一种实时物体检测的新方法</title>
      <link>https://www.reddit.com/r/programming/comments/1oi9ak9/anthony_of_bostons_armaaruss_detection_a_novel/</link>
      <description><![CDATA[ 由   提交 /u/thedowcast   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi9ak9/anthony_of_bostons_armaaruss_detection_a_novel/</guid>
      <pubDate>Tue, 28 Oct 2025 13:25:41 GMT</pubDate>
    </item>
    <item>
      <title>更快的数据库查询：实用技术</title>
      <link>https://www.reddit.com/r/programming/comments/1oi99yw/faster_database_queries_practical_techniques/</link>
      <description><![CDATA[在 Medium 上发布了一篇新文章，如果您从事高可用性和高可用性方面的工作，请访问：可扩展的系统，您可能会发现它很有用   由   提交/u/Trust_Me_Bro_4sure  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi99yw/faster_database_queries_practical_techniques/</guid>
      <pubDate>Tue, 28 Oct 2025 13:25:01 GMT</pubDate>
    </item>
    <item>
      <title>如何可靠地转账 10 欧元</title>
      <link>https://www.reddit.com/r/programming/comments/1oi8ip1/how_to_transfer_10_eur_reliably/</link>
      <description><![CDATA[任务是通过 API 调用转账 10 欧元。这个问题在现实世界中总是会出现。例如，当顾客在电商店购买商品时，后端需要进行支付并预订订单。通常这些操作分布在第三方服务提供商和内部数据库或几个第三方之间。 目标是在避免重复发布的同时完成操作。 TL;DR — 这是不可能的  这个看似常规的任务是一个分布式共识问题，没有通用的解决方案 我解释了如何解决以下问题的轻松版本： 问题    由   提交 /u/aka-rider   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi8ip1/how_to_transfer_10_eur_reliably/</guid>
      <pubDate>Tue, 28 Oct 2025 12:51:27 GMT</pubDate>
    </item>
    <item>
      <title>现场编码恍惚</title>
      <link>https://www.reddit.com/r/programming/comments/1oi8818/live_coding_trance/</link>
      <description><![CDATA[ 由   提交/u/DelilahsDarkThoughts   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi8818/live_coding_trance/</guid>
      <pubDate>Tue, 28 Oct 2025 12:38:24 GMT</pubDate>
    </item>
    <item>
      <title>想要更好的安全性吗？像攻击者一样进行测试</title>
      <link>https://www.reddit.com/r/programming/comments/1oi5uty/want_better_security_test_like_attackers_would/</link>
      <description><![CDATA[ 由   提交 /u/shift_devs   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi5uty/want_better_security_test_like_attackers_would/</guid>
      <pubDate>Tue, 28 Oct 2025 10:36:46 GMT</pubDate>
    </item>
    <item>
      <title>JSON Query - 一种小型、灵活且可扩展的 JSON 查询语言</title>
      <link>https://www.reddit.com/r/programming/comments/1oi5kjt/json_query_a_small_flexible_and_expandable_json/</link>
      <description><![CDATA[ 由   提交/u/BrewedDoritos  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi5kjt/json_query_a_small_flexible_and_expandable_json/</guid>
      <pubDate>Tue, 28 Oct 2025 10:19:55 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 i18next 测试和替换任何缺失的翻译</title>
      <link>https://www.reddit.com/r/programming/comments/1oi5f42/how_to_test_and_replace_any_missing_translations/</link>
      <description><![CDATA[我最近在使用 i18next 时发现了一种非常实用的方法来检测和填充缺失的翻译，老实说，当您有数十个 JSON 文件需要维护时，它可以节省大量时间。 第 1 步 - 测试缺失的翻译 您现在可以自动检查本地化文件中是否缺少任何键。它适用于您的 CLI、CI/CD 管道，甚至您的 Jest/Vitest 测试套件。 示例： npx intlayer test:i18next 它会扫描您的代码库，将其与 JSON 文件进行比较，并输出哪些密钥丢失或未使用。在部署或合并 PR 之前非常方便。 第 2 步 - 自动填充缺失的翻译 您可以选择 AI 提供商（ChatGPT、Claude、DeepSeek 或 Mistral）并使用您自己的 API 密钥自动填充缺失的条目。仅翻译缺失的字符串，现有字符串保持不变。 示例： npx intlayer trans:i18next --provider=chatgpt 它将为所有语言环境中缺失的键生成翻译。 第 3 步 — 集成到 CI/CD 中 您可以将其插入 CI 以确保没有新的缺失键 介绍： npx intlayer test:i18next --ci 如果发现缺少翻译，它可能会使管道失败或仅根据您的配置记录警告。 奖励：通过 Git 检测 JSON 更改甚至有一个 (WIP) 功能可以使用 git diff 检测翻译 JSON 中的哪些行发生更改，因此它只重新翻译原来的内容 已修改。 如果您使用 Next.js 以下指南解释了如何使用 next-i18next 进行设置（基于 i18next）：👉 https://intlayer.org/fr/blog/intlayer-with-next-i18next TL;DR 自动测试缺失的翻译 使用 AI 自动填充缺失的 JSON 条目 与 CI/CDWorks 集成 i18next   由   提交/u/AdmirableJackfruit59   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oi5f42/how_to_test_and_replace_any_missing_translations/</guid>
      <pubDate>Tue, 28 Oct 2025 10:11:00 GMT</pubDate>
    </item>
    </channel>
</rss>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 22 Dec 2025 02:05:34 GMT</lastBuildDate>
    <item>
      <title>人工智能编码工具不是问题，缺乏责任才是问题</title>
      <link>https://www.reddit.com/r/programming/comments/1psl2t0/ai_coding_tools_are_not_the_problem_lack_of/</link>
      <description><![CDATA[ 由   提交/u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psl2t0/ai_coding_tools_are_not_the_problem_lack_of/</guid>
      <pubDate>Mon, 22 Dec 2025 00:04:17 GMT</pubDate>
    </item>
    <item>
      <title>功能团队谬误</title>
      <link>https://www.reddit.com/r/programming/comments/1psj85f/the_feature_team_fallacy/</link>
      <description><![CDATA[ 由   提交/u/ArtisticProgrammer11  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psj85f/the_feature_team_fallacy/</guid>
      <pubDate>Sun, 21 Dec 2025 22:40:19 GMT</pubDate>
    </item>
    <item>
      <title>Langjam-Gamejam 开发日志：52 小时内制作语言、编译器、VM 和 5 个游戏</title>
      <link>https://www.reddit.com/r/programming/comments/1psgpyh/langjamgamejam_devlog_making_a_language_compiler/</link>
      <description><![CDATA[ 由   提交 /u/syn-9  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psgpyh/langjamgamejam_devlog_making_a_language_compiler/</guid>
      <pubDate>Sun, 21 Dec 2025 20:50:19 GMT</pubDate>
    </item>
    <item>
      <title>我在初级开发人员中经常看到 Git 的困惑：fetch 与 pull</title>
      <link>https://www.reddit.com/r/programming/comments/1psd3r3/a_git_confusion_i_see_a_lot_with_junior_devs/</link>
      <description><![CDATA[我见过不少初级开发人员在 git pull 突然引发冲突时陷入困境，即使他们“只是想要最新的代码”。 我针对初级开发人员写了一个简短的解释，但结果却崩溃了：  git fetch 实际上做了什么 为什么 git pull 在分支不干净 其中git pull --rebase适合  没有理论转储。只是帮助我的团队的真实例子和心智模型。分享以防有人避免令人困惑的第一次 Git 冲突。   由   提交/u/sshetty03  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psd3r3/a_git_confusion_i_see_a_lot_with_junior_devs/</guid>
      <pubDate>Sun, 21 Dec 2025 18:17:38 GMT</pubDate>
    </item>
    <item>
      <title>AlloyDB for PostgreSQL：熟悉的 SQL，非常陌生的性能特征</title>
      <link>https://www.reddit.com/r/programming/comments/1psclu3/alloydb_for_postgresql_familiar_sql_very/</link>
      <description><![CDATA[AlloyDB 看起来就像“GCP 上的 Postgres”，直到您实际在其上运行实际工作负载。令人惊讶的是，快速查询性能与普通 Postgres 不同，存储和计算扩展改变了您对瓶颈的看法，读取池悄然重塑了应用程序的架构方式。它很强大，但前提是您了解 Google 在幕后修改了什么以及它与自我管理或 Cloud SQL Postgres 的不同之处。此细分解释了 AlloyDB 的优化内容、它的优点以及传统 Postgres 的假设可能会给您带来麻烦的地方： AlloyDB   由   提交/u/netcommah  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psclu3/alloydb_for_postgresql_familiar_sql_very/</guid>
      <pubDate>Sun, 21 Dec 2025 17:57:11 GMT</pubDate>
    </item>
    <item>
      <title>云代码感觉很神奇，直到您意识到它实际上抽象了什么</title>
      <link>https://www.reddit.com/r/programming/comments/1pscjp2/cloud_code_feels_magical_until_you_realize_what/</link>
      <description><![CDATA[Cloud Code 看起来在第一天就取得了生产力的胜利；从 IDE 进行部署，立即预览资源，减少 YAML 麻烦。但真正的价值（和风险）是它所抽象的：IAM 布线、部署上下文、环境漂移以及“本地 == 产品”的错误观念。团队的行动速度更快，但如果不了解 Cloud Code 在幕后生成和管理的内容，调试和扩展可能会很快变得混乱。这篇文章详细介绍了 Cloud Code 真正有帮助的地方、它可以隐藏复杂性的地方，以及如何使用它而不将您的 IDE 变成黑匣子： Cloud Code   由   提交/u/netcommah  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pscjp2/cloud_code_feels_magical_until_you_realize_what/</guid>
      <pubDate>Sun, 21 Dec 2025 17:54:39 GMT</pubDate>
    </item>
    <item>
      <title>对青少年的赌注变得更好</title>
      <link>https://www.reddit.com/r/programming/comments/1pscemt/the_bet_on_juniors_just_got_better/</link>
      <description><![CDATA[ 由   提交/u/phillipcarter2  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pscemt/the_bet_on_juniors_just_got_better/</guid>
      <pubDate>Sun, 21 Dec 2025 17:48:44 GMT</pubDate>
    </item>
    <item>
      <title>负载平衡听起来很简单，但在流量实际激增之前。人们会犯这样的错误</title>
      <link>https://www.reddit.com/r/programming/comments/1psbwq0/load_balancing_sounds_simple_until_traffic/</link>
      <description><![CDATA[负载平衡通常被描述为“只是将流量分散到服务器上”，但是当实际流量出现时，这个定义就崩溃了。当后端在技术上“健康”但速度慢得令人痛苦时，当粘性会话悄悄地破坏有状态的应用程序时，或者当重试和超时使您的流量在您没有注意到的情况下翻倍时，真正的失败就会发生。在规模上，负载平衡不再与分布有关，而是开始与故障管理有关——健康检查可能会撒谎，循环法在负载不均匀的情况下会崩溃，而没有正确的平衡策略的自动扩展只会使问题成倍增加。  此细分解释了教科书负载平衡与生产现实的差异，包括 L4 与 L7 的权衡，以及为什么“均匀流量”通常是错误的目标：负载平衡   由   提交/u/netcommah  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psbwq0/load_balancing_sounds_simple_until_traffic/</guid>
      <pubDate>Sun, 21 Dec 2025 17:28:00 GMT</pubDate>
    </item>
    <item>
      <title>在此之后 Git 终于有意义了</title>
      <link>https://www.reddit.com/r/programming/comments/1psb1sp/git_will_finally_make_sense_after_this/</link>
      <description><![CDATA[ 由   提交/u/DrDOS  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psb1sp/git_will_finally_make_sense_after_this/</guid>
      <pubDate>Sun, 21 Dec 2025 16:52:30 GMT</pubDate>
    </item>
    <item>
      <title>再见微服务 - Twilio 开发者博客</title>
      <link>https://www.reddit.com/r/programming/comments/1psax77/goodbye_microservices_twilio_developers_blog/</link>
      <description><![CDATA[ 由   提交/u/vladmihalceacom   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psax77/goodbye_microservices_twilio_developers_blog/</guid>
      <pubDate>Sun, 21 Dec 2025 16:47:14 GMT</pubDate>
    </item>
    <item>
      <title>Crunch：用于正确处理事情的消息定义和序列化协议</title>
      <link>https://www.reddit.com/r/programming/comments/1ps9y9k/crunch_a_message_definition_and_serialization/</link>
      <description><![CDATA[Crunch 是我使用现代 C++ 开发的一个工具，用于定义、序列化和反序列化消息。考虑一下 protobuf、flatbuffers、bebop 和 mavLINK 的领域。 我开发了 crunch 来解决我对这些现有协议中的接口设计的一些不满。它具有以下功能： 1. 需要字段和消息级别验证。需要。使程序中的字段在语义上正确的因素已融入 C++ 类型系统中。  序列化格式是一个插件。您可以选择读/写速度优化的序列化、protobuf 式标记长度值插件，或编写您自己的插件。 消息内置了完整性检查。 Crunch 附带了 CRC-16 或奇偶校验，您也可以编写自己的校验。 无动态内存分配。使用模板魔法，Crunch 计算所有消息类型、所有序列化协议的最坏情况长度，并公开 constexpr API 来创建用于序列化和反序列化的缓冲区。  我对到目前为止的结果非常满意。我试图通过提供 bazel 和 cmake 目标以及大量文档来使其超级易于使用。未来的工作包括通过 QEMU 自动执行跨平台集成测试、尽可能多地注册包管理器以及用其他语言创建绑定。  希望 Crunch 能够在您的项目中发挥作用！我已经写了关于 Crunch 开发的一系列博客文章中的第一篇，如果您有兴趣，可以在我的个人资料中链接！   由   提交/u/volatile-int   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps9y9k/crunch_a_message_definition_and_serialization/</guid>
      <pubDate>Sun, 21 Dec 2025 16:06:16 GMT</pubDate>
    </item>
    <item>
      <title>Go 中公平的、可取消的信号量</title>
      <link>https://www.reddit.com/r/programming/comments/1ps9s8m/a_fair_cancelable_semaphore_in_go/</link>
      <description><![CDATA[ 由   提交/u/candurz   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps9s8m/a_fair_cancelable_semaphore_in_go/</guid>
      <pubDate>Sun, 21 Dec 2025 15:59:39 GMT</pubDate>
    </item>
    <item>
      <title>MCP是否被过度炒作？</title>
      <link>https://www.reddit.com/r/programming/comments/1ps8y5v/is_mcp_overhyped/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps8y5v/is_mcp_overhyped/</guid>
      <pubDate>Sun, 21 Dec 2025 15:23:33 GMT</pubDate>
    </item>
    <item>
      <title>Constvector：日志结构的 std:vector 替代方案 – 推送/弹出速度提高 30-40%</title>
      <link>https://www.reddit.com/r/programming/comments/1ps8s9e/constvector_logstructured_stdvector_alternative/</link>
      <description><![CDATA[通常 std::vector 以 &#39;N&#39; 容量开始，一旦其大小超过 X，就会增长到 &#39;2 * N&#39; 容量；此时，我们也将旧数组中的数据复制到新数组中。这几乎没有问题 1.复制成本，2.操作系统需要管理应用程序释放的小容量数组（大小N）。3.L1和L2缓存需要使数组项无效，因为数组移动到新位置，并且CPU需要获取L1/L2，因为它是CPU的新数据，但实际上并非如此。  std::vector 的重新分配和重新复制的摊销时间为 O(1)，但在低级别时它们会产生很多负面影响。这是一个具有 2 次幂块的对数结构替代方案（constvector）： Push：3.5 ns/op（vs 5 ns std::vector） Pop：3.4 ns/op（vs 5.3 ns） Index：轻微减速（3.8 vs 3.4 ns）严格最坏情况 O(1)、θ(N) 空间权衡，与相比仅 log(N) 额外std::vector。 它减少了内部内存碎片。它不会在不进行修改的情况下使 L1、L2 缓存失效，从而提高性能：在 github 中，我对 1K 到 1B 大小的向量进行了基准测试，这种持续改进显示了推送和弹出操作的更好性能。  Youtube：https://youtu.be/ledS08GkD40 实际上我们可以使用 64 大小对于元数组（对于 log(N)）作为额外空间。我实现了裸向量操作来进行比较，因为实际的 std::vector 实现有很多迭代器验证代码，导致额外的开销。   由   提交/u/pilotwavetheory  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps8s9e/constvector_logstructured_stdvector_alternative/</guid>
      <pubDate>Sun, 21 Dec 2025 15:16:15 GMT</pubDate>
    </item>
    <item>
      <title>React 和其他一些也有一个，现在我们有 1 个用于 php</title>
      <link>https://www.reddit.com/r/programming/comments/1ps8179/react_and_a_few_other_have_one_too_now_we_have_1/</link>
      <description><![CDATA[我们有 https://justfuckingusehtml.com 然后是用于 React、is 和 vue 等。 我看到没有用于 php het 的，所以我决定也为此制作一个。 请随意查看并享受。 祝您即将到来假期！！ 注意，这不是为了宣传、展示或为了初创公司。我只是想分享这个 même 网站以供娱乐，无论如何它只是一个页面   由   提交 /u/Minute_Attempt3063   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps8179/react_and_a_few_other_have_one_too_now_we_have_1/</guid>
      <pubDate>Sun, 21 Dec 2025 14:41:47 GMT</pubDate>
    </item>
    </channel>
</rss>
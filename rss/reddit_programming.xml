<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 12 Feb 2026 07:08:24 GMT</lastBuildDate>
    <item>
      <title>在法学硕士时代保持领先地位</title>
      <link>https://www.reddit.com/r/programming/comments/1r2mk8n/staying_on_top_in_the_age_of_llms/</link>
      <description><![CDATA[ 由   提交/u/andras_gerlits  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2mk8n/staying_on_top_in_the_age_of_llms/</guid>
      <pubDate>Thu, 12 Feb 2026 06:53:34 GMT</pubDate>
    </item>
    <item>
      <title>Slopacolypse 已经到来：Karpathy 警告 2026 年工作流程将出现“废用萎缩”。我们是成为高级架构师还是只是懒惰的审计师？</title>
      <link>https://www.reddit.com/r/programming/comments/1r2mct9/the_slopacolypse_is_here_karpathy_warns_of_disuse/</link>
      <description><![CDATA[2025 年末，Andrej Karpathy 承认他已经停止手动编写代码两个月了。他的比例从 80% 手动转变为 80% 人工智能。他称 2026 年是该行业必须“新陈代谢”的一年。这些能力。 核心问题：我们正在从“瓦工”转变为“瓦工”。对于“建筑师”来说，但我们正在失去搬砖的感觉。 Karpathy 警告“微妙的概念错误”——AI 代码看起来很完美，通过了单元测试，但却引入了高级逻辑腐烂（死代码、过度抽象和“失范”）。 2026 年现实：  技能萎缩： 手动内存管理和调试并发死锁正在变得“迷失” ” 审核负担：审核时间现在延长了 10 倍，因为我们必须审核数千行“令人信服的废话”。几秒钟内生成。 开发商分裂：市场正在分裂为“建筑商”和“开发商”。 （使用人工智能作为杠杆工具的人）和“程序员” （谁实际上被取代了）。  100 美元\times 的效率提升值得损失底层系统理解吗？或者这只是“软件2.0”的自然演变？   由   提交/u/jakubb_69  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2mct9/the_slopacolypse_is_here_karpathy_warns_of_disuse/</guid>
      <pubDate>Thu, 12 Feb 2026 06:40:48 GMT</pubDate>
    </item>
    <item>
      <title>人工智能编码杀死了我的心流状态</title>
      <link>https://www.reddit.com/r/programming/comments/1r2l8i5/ai_coding_killed_my_flow_state/</link>
      <description><![CDATA[您认为更多的人会不再享受这份曾经充满活力但现在却让内向者精疲力尽的工作吗？   由   提交 /u/Fantastic-Cress-165   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2l8i5/ai_coding_killed_my_flow_state/</guid>
      <pubDate>Thu, 12 Feb 2026 05:37:33 GMT</pubDate>
    </item>
    <item>
      <title>解构“第一天到数百万”系统设计基线：对标准扩展路径的批评</title>
      <link>https://www.reddit.com/r/programming/comments/1r2jdxb/deconstructing_the_day_1_to_millions_system/</link>
      <description><![CDATA[在现代系统设计面试中，有一个规范的“扩展路径”：候选人预计会抽签。虽然对于表明资历很有用，但这条路径常常偏离实际的 Web 开发需求。 我一直在分析标准的“第一天到百万”的标准。进展：单实例 → 外部数据库 → 垂直与水平扩展 → 负载均衡器 → 读取副本 → 缓存策略 架构假设：  解耦：第一步几乎总是将存储 (DB) 与计算解耦，以允许无状态扩展。 冗余：引入负载均衡器（LB）假设应用程序已经是无状态的；然而，在实践中，处理会话状态（粘性会话与 Redis 等分布式缓存）通常是 LB 可行之前的直接阻碍。 大量读取优化：标准路径默认为只读副本 + 缓存。这假设了较高的读：写比率（例如，100:1），这对于社交源来说是典型的，但对于写入大量的日志记录或聊天系统来说是不正确的。  分歧：该图的版本通常忽略一致性的操作开销。一旦从单数据库转移到主从复制，您会立即遇到 CAP 定理权衡（最终一致性），但大多数“基线”都是基于 CAP 定理的。在出现提示之前，图表会掩盖这种复杂性。 对于那些浏览这些访谈的人来说，将此流程视为“清单”是很重要的。如果没有明确调用“负载均衡器”上的状态管理和一致性权衡，这是危险的。和“复制”    由   提交/u/THE_RIDER_69   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2jdxb/deconstructing_the_day_1_to_millions_system/</guid>
      <pubDate>Thu, 12 Feb 2026 04:02:12 GMT</pubDate>
    </item>
    <item>
      <title>Game Boy Advance 音频插值</title>
      <link>https://www.reddit.com/r/programming/comments/1r2hsoh/game_boy_advance_audio_interpolation/</link>
      <description><![CDATA[ 由   提交/u/NXGZ   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r2hsoh/game_boy_advance_audio_interpolation/</guid>
      <pubDate>Thu, 12 Feb 2026 02:46:47 GMT</pubDate>
    </item>
    <item>
      <title>Go - 单元和集成测试</title>
      <link>https://www.reddit.com/r/programming/comments/1r297wt/go_unit_integration_testing/</link>
      <description><![CDATA[嗨。我想制作一份关于如何在 Go 中进行单元/集成测试的详细指南，我觉得好像没有足够的指南来帮助分解它并彻底解释它。希望如此。本文实现了这一点。在写这篇文章时，我决定采用直接编写 Go 代码的人的心态。可能不了解 docker，或者测试 go 代码所涉及的库。 本文涵盖哪些内容？  我们为什么要测试？ 软件测试背后的主要方法 什么是接口？ 什么是依赖注入？ 如何安装所需的依赖项 示例项目 单元测试 什么是容器？ 集成测试  写这篇文章花费了令人难以置信的时间，我希望这对某人有帮助！ 如果有人有任何反馈，请随时发表评论。   由   提交/u/CallumMVS-  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r297wt/go_unit_integration_testing/</guid>
      <pubDate>Wed, 11 Feb 2026 20:51:03 GMT</pubDate>
    </item>
    <item>
      <title>我们使用 Rust 为 Node.js 构建了更好的 Cassandra + ScyllaDB 驱动程序</title>
      <link>https://www.reddit.com/r/programming/comments/1r28cda/we_built_a_better_cassandra_scylladb_driver_for/</link>
      <description><![CDATA[为 ScyllaDB 构建 Rust 支持的 Node.js 驱动程序的经验教训：桥接 JS 和 Rust、性能陷阱和基准测试结果   由   提交 /u/swdevtest   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r28cda/we_built_a_better_cassandra_scylladb_driver_for/</guid>
      <pubDate>Wed, 11 Feb 2026 20:18:00 GMT</pubDate>
    </item>
    <item>
      <title>Microsoft 停止使用多语言笔记本（C# Interactive）</title>
      <link>https://www.reddit.com/r/programming/comments/1r28bdg/microsoft_discontinues_polyglot_notebooks_c/</link>
      <description><![CDATA[Polyglot Notebooks (C# Interactive) 的维护者刚刚通知我，它也将停止使用。 dotnet/interactive#4071 (comment) Polyglot 仍被列为分析师将 SQL 笔记本从 ADS 迁移出去的推荐工具。 https://learn.microsoft.com/en-us/sql/tools/whats-happening-azure-data-studio?view=sql-server-ver17&amp;tabs=analyst 编辑：他们已删除参考 此处的建议是将笔记本转换为基于文件的应用程序。 SQL 笔记本的主要好处是您不必成为开发人员即可使用它们。 dotnet/interactive#4163 我花了一周时间整理了一个 PR，以更好地将 Polyglot 与 vscode-mssql 集成。这种行为对于 OSS 来说非常糟糕。   由   提交 /u/WhitelabelDnB   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r28bdg/microsoft_discontinues_polyglot_notebooks_c/</guid>
      <pubDate>Wed, 11 Feb 2026 20:16:59 GMT</pubDate>
    </item>
    <item>
      <title>与 Claude 结对编程：我如何使用 AI 自学 Rust</title>
      <link>https://www.reddit.com/r/programming/comments/1r26y3y/pair_programming_with_claude_how_i_used_ai_to/</link>
      <description><![CDATA[ 由   提交 /u/Lame_Johnny   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r26y3y/pair_programming_with_claude_how_i_used_ai_to/</guid>
      <pubDate>Wed, 11 Feb 2026 19:26:33 GMT</pubDate>
    </item>
    <item>
      <title>宣布推出 TypeScript 6.0 Beta</title>
      <link>https://www.reddit.com/r/programming/comments/1r25zkp/announcing_typescript_60_beta/</link>
      <description><![CDATA[ 由   提交/u/DanielRosenwasser   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r25zkp/announcing_typescript_60_beta/</guid>
      <pubDate>Wed, 11 Feb 2026 18:51:50 GMT</pubDate>
    </item>
    <item>
      <title>如何做出架构决策：RFC、ADR 以及让每个人保持一致</title>
      <link>https://www.reddit.com/r/programming/comments/1r22ia1/how_to_make_architecture_decisions_rfcs_adrs_and/</link>
      <description><![CDATA[ 由   提交 /u/archunit   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r22ia1/how_to_make_architecture_decisions_rfcs_adrs_and/</guid>
      <pubDate>Wed, 11 Feb 2026 16:48:07 GMT</pubDate>
    </item>
    <item>
      <title>如何保持烟雾测试有用</title>
      <link>https://www.reddit.com/r/programming/comments/1r21nfq/how_to_keep_your_smoke_testing_useful/</link>
      <description><![CDATA[ 由   提交/u/MiserableWriting2919  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r21nfq/how_to_keep_your_smoke_testing_useful/</guid>
      <pubDate>Wed, 11 Feb 2026 16:16:33 GMT</pubDate>
    </item>
    <item>
      <title>让编码代理与数据库交互的安全方法（无需产品写入访问权限）</title>
      <link>https://www.reddit.com/r/programming/comments/1r20ku2/a_safe_way_to_let_coding_agents_interact_with/</link>
      <description><![CDATA[许多团队尝试通过阻止 SQL 写入、添加命令允许列表或插入批准对话框来确保编码代理的安全。 实际上，这行不通。 如果代理具有任何通用执行表面（shell、运行时、文件系统），它最终将绕过这些限制来完成任务。我们多次看到代理生成自己的脚本并修改状态，即使仅公开只读数据库工具也是如此。 我整理了一个教程，展示了更安全的模式：  完全隔离生产 让代理仅在可写克隆上运行 需要迁移/脚本作为输出工件 将生产更新保留在现有部署管道内  ---- ⚠️由于下面评论中的误解，有一个重要的安全通知：本教程中的第 1 层故意不安全 - 不要不要在生产环境中运行。它只是为了展示代理如何绕过约束。安全工作流程是第 2 层：使用可写克隆，生成经过审查的迁移脚本，并通过正常管道推送更改。 代理不应接触生产凭据。本教程是关于教授安全隔离实践，而不是授予 AI 产品访问权限。   由   提交 /u/National_Purpose5521   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r20ku2/a_safe_way_to_let_coding_agents_interact_with/</guid>
      <pubDate>Wed, 11 Feb 2026 15:36:24 GMT</pubDate>
    </item>
    <item>
      <title>为什么专家（程序员）很难沟通</title>
      <link>https://www.reddit.com/r/programming/comments/1r1xlcc/why_experts_programmers_find_it_hard_to/</link>
      <description><![CDATA[曾经遇到过如此聪明的人，但无法解释他们的应用程序/软件的最基本部分（想想硅谷的Pied Piper以及他们泡沫之外的人如何无法理解他们的产品）？ 这并不是因为他们沟通能力差。这是一个心理盲点，称为“知识的诅咒”。一旦你知道了某件事，你就会忘记不知道它是什么感觉。  1990 年，斯坦福大学的一项研究表明，“敲击者”会在不知道它的情况下进行操作。 （人们敲击歌曲节奏）预测听众有 50% 的机会猜出这首歌。只有 2.5% 猜对了。 苹果公司支付了 5 亿美元的和解金，因为一项实际上有效但无法通信的功能 苹果公司就电池节流功能支付了 5 亿美元的和解金，该功能实际上可以节省电池寿命，但因为他们没有解释“为什么”，所以苹果公司支付了 5 亿美元的和解金。用户用自己的阴谋论填补了这一空白。  本文详细介绍了这些显而易见的事情是如何最难解释的，以及这种差距如何在工程、用户体验、教育和文档中出现。   由   提交/u/Vast-Drawing-98   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r1xlcc/why_experts_programmers_find_it_hard_to/</guid>
      <pubDate>Wed, 11 Feb 2026 13:37:37 GMT</pubDate>
    </item>
    <item>
      <title>安全性和 DevEx：我们可以两者兼得吗？ • Abby Bangser、Adrian Mouat 和 Holly Cummins</title>
      <link>https://www.reddit.com/r/programming/comments/1r1xa33/security_devex_can_we_have_both_abby_bangser/</link>
      <description><![CDATA[ 由   提交 /u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1r1xa33/security_devex_can_we_have_both_abby_bangser/</guid>
      <pubDate>Wed, 11 Feb 2026 13:24:07 GMT</pubDate>
    </item>
    </channel>
</rss>
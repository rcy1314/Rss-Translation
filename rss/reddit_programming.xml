<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Wed, 17 Dec 2025 21:26:46 GMT</lastBuildDate>
    <item>
      <title>为跨 Win32 和 Win64 的纯汇编框架设计稳定的 ABI</title>
      <link>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</link>
      <description><![CDATA[我一直在探索如何在纯汇编中编写重要的软件，而不需要跨架构复制逻辑。 主要挑战之一是规范逻辑 ABI 层背后截然不同的 Win32 和 Win64 调用约定。 关键设计点： - 核心代码从不直接引用架构寄存器 - 逻辑参数/返回约定通过宏映射到每个平台 - 堆栈集中执行纪律和寄存器保存规则 - 这允许在 x86 和 x86-64 上构建相同的核心逻辑 这种方法使小型 ASCII/2D 游戏框架能够跨架构共享所有核心逻辑，而无需条件代码。 我编写了设计并在以下位置提供了完整的源示例：GitHub.com/Markusdulree-art/GLYPH-FRAMEWORK 我很好奇其他人是如何实现 ABI 标准化的。   由   提交/u/Easy-Zone-4141   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</guid>
      <pubDate>Wed, 17 Dec 2025 21:25:15 GMT</pubDate>
    </item>
    <item>
      <title>PR 不足以调试代理编写的代码</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</link>
      <description><![CDATA[在我作为软件工程师的经验中，我们经常按以下顺序解决生产错误：  待命通知 Sentry、datadog、PagerDuty 中存在问题 我们找出它与哪个 PR 相关 责怪执行 PR 的人 告诉他们修复它并更新单元测试  尽管如此，这里的关键问题是 PR 会告诉您错误发生的位置。 使用代理代码，它们通常不会告诉您代理为何进行更改。 使用代理编码，单个 PR 现在的最终输出是：  提示 + 修订 错误/陈旧的存储库上下文 静默失败的工具调用（身份验证/超时） 约束不匹配（不强制执行“请勿触摸计费”）  因此，我开始认为事件响应需要“代理可追溯性”：  提示/上下文引用 工具调用时间线/结果 关键决策点 将编辑映射到会话  本质上，为了让我们更好地调试，我们需要对代理以某种方式开发的原因有一个根本的推理，而不仅仅是代码的输出。 编辑：打字错误：x 更新：第3步意味着git的责任，而不是谴责个人。   由   提交 /u/brandon-i   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</guid>
      <pubDate>Wed, 17 Dec 2025 19:39:47 GMT</pubDate>
    </item>
    <item>
      <title>当实现一种小型解释语言时令我惊讶的是（解析是简单的部分）</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</link>
      <description><![CDATA[在实现小型解释语言作为学习练习时，我预计解析是最难的部分。事实证明，它是更简单的组件之一。 花费最多时间的部分是错误诊断、执行语义和控制流边缘情况，即使语法非常小。 在实现过程中突出的一些事情： 1。错误处理在早期设计中占主导地位 最小的语法仍然会产生许多失败模式。 需要有意义的错误：  保留标记范围（行/列范围） 延迟一些检查直到语义分析 报告预期的结构而不是一般的失败  没有这个，语言在技术上是正确的，但无法使用。 2. Pratt 解析简化了语法，而不是语义 使用 Pratt 解析器使表达式解析变得紧凑和灵活，但是：  语句边界 作用域规则 函数返回与程序终止  无论解析器是否简单，都需要显式的 VM 级处理。 3.基于堆栈的虚拟机很快就会暴露出设计缺陷 即使是基本的虚拟机也被迫做出以下决策：  调用帧与全局状态 函数如何在不停止执行的情况下返回 导入如何影响运行时状态  这些问题只有在运行重要程序时才会出现。 要点 构建“真实”程序发现了设计问题比单元测试快得多。大多数复杂性不是来自功能，而是来自在边缘情况下定义正确的行为。 如果有人想深入了解细节，我在这里记录了完整的实现（词法分析器→解析器→字节码→VM）。单击链接。   由   提交/u/Imaginary-Pound-1729   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</guid>
      <pubDate>Wed, 17 Dec 2025 19:25:51 GMT</pubDate>
    </item>
    <item>
      <title>这些年来我一直在错误地写环形缓冲区</title>
      <link>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</link>
      <description><![CDATA[ 由   提交/u/BrewedDoritos  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</guid>
      <pubDate>Wed, 17 Dec 2025 19:05:57 GMT</pubDate>
    </item>
    <item>
      <title>内联——终极优化</title>
      <link>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</link>
      <description><![CDATA[ 由   提交/u/emschwartz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</guid>
      <pubDate>Wed, 17 Dec 2025 16:46:28 GMT</pubDate>
    </item>
    <item>
      <title>Ruby 4.0 中的新增功能</title>
      <link>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</link>
      <description><![CDATA[ 由   提交 /u/nithinbekal   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</guid>
      <pubDate>Wed, 17 Dec 2025 16:40:48 GMT</pubDate>
    </item>
    <item>
      <title>TornadoVM 2.0 为 Java 带来自动 GPU 加速和 LLM 支持</title>
      <link>https://www.reddit.com/r/programming/comments/1pp129e/tornadovm_20_brings_automatic_gpu_acceleration/</link>
      <description><![CDATA[ 由   提交/u/benevanstech  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp129e/tornadovm_20_brings_automatic_gpu_acceleration/</guid>
      <pubDate>Wed, 17 Dec 2025 16:32:44 GMT</pubDate>
    </item>
    <item>
      <title>进一步优化我的 Java SwissTable：配置文件污染和 SWAR 探测</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0wg2/further_optimizing_my_java_swisstable_profile/</link>
      <description><![CDATA[大家好。 跟进我上一篇文章，我在 JVM 上构建了一个 SwissTable 式的哈希映射： https://www.reddit.com/r/programming/comments/1plbpzg/building_a_fast_memoryefficient_hash_table_in/ 这次我使用分析器返回并优化了实际热路径(findIndex)。 由于配置文件污染/错过了去虚拟化，大量时间都花在了 Objects.equals() 上。解决这个问题后，下一个瓶颈是 ARM/NEON“movemask”问题（VectorMask.toLong()），所以我尝试了 SWAR...并且最终速度更快（即使在 x86 上也是如此，这是我没想到的）。   由   提交/u/Charming-Top-8583  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0wg2/further_optimizing_my_java_swisstable_profile/</guid>
      <pubDate>Wed, 17 Dec 2025 16:26:38 GMT</pubDate>
    </item>
    <item>
      <title>Next.js 中的运行时环境变量 - 构建可重用的 Docker 镜像</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0mpk/runtime_environment_variables_in_nextjs_build/</link>
      <description><![CDATA[ 由   提交 /u/Ok_Animator_1770   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0mpk/runtime_environment_variables_in_nextjs_build/</guid>
      <pubDate>Wed, 17 Dec 2025 16:16:08 GMT</pubDate>
    </item>
    <item>
      <title>SSD 数据库是什么样的？</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0gyg/what_does_a_database_for_ssds_look_like/</link>
      <description><![CDATA[ 由   提交/u/emschwartz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0gyg/what_does_a_database_for_ssds_look_like/</guid>
      <pubDate>Wed, 17 Dec 2025 16:09:56 GMT</pubDate>
    </item>
    <item>
      <title>Stack Overflow 年度调查</title>
      <link>https://www.reddit.com/r/programming/comments/1pozw5i/stack_overflow_annual_survey/</link>
      <description><![CDATA[我的一些（主观）令人惊讶的收获：  Haskell、Clojure、Nix 没有列出语言列表，只是写入。 Clojure 真的让我很惊讶，因为它没有名列前茅，但 Lisp 却名列前茅！也许是因为所有 Lisp 方言（包括 Clojure）的程序员都自称是 Lisp 用户。 Emacs 没有进入顶级编辑器列表，只是写入 Gleam 是最受推崇的语言之一（以前从未听说过！） Rust、Cargo 最受推崇的语言和构建工具 - 考虑到 Rust 炒作，这并不奇怪 uv 是最受推崇的技术标签 - 并不奇怪，因为它是用 Rust 实现的流行 Python 工具  你们对今年的调查结果有何看法？你参加了吗？   由   提交/u/sohang-3112  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pozw5i/stack_overflow_annual_survey/</guid>
      <pubDate>Wed, 17 Dec 2025 15:47:56 GMT</pubDate>
    </item>
    <item>
      <title>在 Hacktoberfest 期间维护开源软件</title>
      <link>https://www.reddit.com/r/programming/comments/1poznp6/maintaining_an_open_source_software_during/</link>
      <description><![CDATA[ 由   提交/u/CrociDB   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1poznp6/maintaining_an_open_source_software_during/</guid>
      <pubDate>Wed, 17 Dec 2025 15:39:10 GMT</pubDate>
    </item>
    <item>
      <title>扔更多的飞镖</title>
      <link>https://www.reddit.com/r/programming/comments/1pozeat/throw_more_darts/</link>
      <description><![CDATA[ 由   提交/u/derwiki  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pozeat/throw_more_darts/</guid>
      <pubDate>Wed, 17 Dec 2025 15:28:55 GMT</pubDate>
    </item>
    <item>
      <title>在最近出现漏洞后探索 Next.js 的替代方案</title>
      <link>https://www.reddit.com/r/programming/comments/1pozd5w/exploring_alternatives_to_nextjs_after_recent/</link>
      <description><![CDATA[ 由   提交 /u/makeKarmaGreatAgain   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pozd5w/exploring_alternatives_to_nextjs_after_recent/</guid>
      <pubDate>Wed, 17 Dec 2025 15:27:39 GMT</pubDate>
    </item>
    <item>
      <title>系统调用：程序如何与 Linux 内核对话</title>
      <link>https://www.reddit.com/r/programming/comments/1poy70l/system_calls_how_programs_talk_to_the_linux_kernel/</link>
      <description><![CDATA[大家好， 我刚刚发布了《Linux Inside Out》系列的第二篇文章。 在第一篇文章中，我们稍微揭开了 Linux 内核的神秘面纱：它位于何处，如何在虚拟机中启动它，我们甚至编写了一个微小的 init 程序。 在第二篇文章中，我们将更深入地了解程序如何与内核实际通信。我们将做一些小实验来看看：  我们的 init 程序（我们在第一篇文章中编写的）如何通过系统调用与内核进行通信 像 `echo “hello”` 这样的东西如何最终在屏幕上打印文本 如何跟踪系统调用以了解程序在做什么  我主要针对那些每天使用 Linux 并对此感到好奇的开发人员和自托管者。基于 Linux 的操作系统的内部结构。 这是一个较长系列的第 2 部分，逐层介绍 Linux 系统，同时努力保持实用性和平易近人。 链接（第 2 部分）：https://serversfor.dev/linux-inside-out/system-calls-how-programs-talk-to-the-linux-kernel/ 链接（第 1 部分）：https://serversfor.dev/linux-inside-out/the-linux-kernel-is-just-a-program/ 欢迎任何反馈。   由   提交 /u/indieHungary   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1poy70l/system_calls_how_programs_talk_to_the_linux_kernel/</guid>
      <pubDate>Wed, 17 Dec 2025 14:40:41 GMT</pubDate>
    </item>
    </channel>
</rss>
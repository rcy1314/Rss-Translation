<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Tue, 30 Dec 2025 02:01:24 GMT</lastBuildDate>
    <item>
      <title>数据模型依赖是一个陷阱</title>
      <link>https://www.reddit.com/r/programming/comments/1pz3yfw/data_model_dependency_is_a_trap/</link>
      <description><![CDATA[ 由   提交/u/Exact_Prior6299  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pz3yfw/data_model_dependency_is_a_trap/</guid>
      <pubDate>Tue, 30 Dec 2025 01:02:32 GMT</pubDate>
    </item>
    <item>
      <title>这是我咨询生涯中的一个金融科技项目的详细分解。</title>
      <link>https://www.reddit.com/r/programming/comments/1pz3v1i/this_is_a_detailed_breakdown_of_a_fintech_project/</link>
      <description><![CDATA[ 由   提交 /u/trolleid   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pz3v1i/this_is_a_detailed_breakdown_of_a_fintech_project/</guid>
      <pubDate>Tue, 30 Dec 2025 00:58:31 GMT</pubDate>
    </item>
    <item>
      <title>内核模式错误是不同的</title>
      <link>https://www.reddit.com/r/programming/comments/1pz3gbz/kernel_mode_bugs_are_different/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pz3gbz/kernel_mode_bugs_are_different/</guid>
      <pubDate>Tue, 30 Dec 2025 00:40:44 GMT</pubDate>
    </item>
    <item>
      <title>InnoDB缓冲池LRU实现：MySQL如何优化内存管理</title>
      <link>https://www.reddit.com/r/programming/comments/1pz0y2g/innodb_buffer_pool_lru_implementation_how_mysql/</link>
      <description><![CDATA[我正在阅读 InnoDB 存储引擎文档，发现他们使用 LRU 的变体进行缓存逐出。 简单的 LRU 实现不适用于数据库工作负载，因为全表扫描将从内存中逐出所有热页。 在较高级别上，InnoDB 结构可以分为  磁盘上持久结构（表空间、重做日志、撤消日志）即保存数据的物理文件。 内存中结构 这是缓冲池所在的位置。它是主内存中的一个区域，InnoDB 在访问时缓存表和索引页。  通过将频繁访问的数据保存在 RAM 中，InnoDB 可以更快地处理查询。在专用数据库服务器上，通常的做法是将最多 80% 的物理内存分配给该池。 InnoDB 使用拆分列表方法而不是标准 LRU： - 新子列表（列表的~5/8）：热门/经常访问的页面 - 旧子列表（列表的~3/8）：最近看到但未经验证的页面 新页面不会直接进入头部。它们被插入到中点（旧子列表的头部），并且仅在后续访问和计时规则之后才提升到新子列表。这会创建一个“隔离”列表。 在全表扫描期间，页面首先填充旧子列表，在有限的空间内进行搅动，同时使新子列表中的工作集保持不变。大多数扫描页只读取一次，从不提升，并且从尾部开始快速老化。 因此，表扫描不会废弃整个缓存。热页保持热状态，扫描页首先被驱逐。   由   提交 /u/Normal-Tangelo-7120   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pz0y2g/innodb_buffer_pool_lru_implementation_how_mysql/</guid>
      <pubDate>Mon, 29 Dec 2025 22:55:45 GMT</pubDate>
    </item>
    <item>
      <title>解决 $N$ 编排问题：我们如何通过 Kafka 扩展 35 个以上的 MCP？</title>
      <link>https://www.reddit.com/r/programming/comments/1pz0wx6/tackling_the_norchestration_problem_how_do_we/</link>
      <description><![CDATA[我们正在构建 slashmcp.com，但我们遇到了令人着迷（但痛苦）的扩展瓶颈。 目标是大规模处理模型上下文协议 (MCP)。我们目前正在集成 35 多个不同的 MCP 并使用 Kafka 进行编排，但随着我们向 $n$ 复杂性迈进，编排逻辑正在成为一个巨大的障碍。 我们决定将问题公开。我们正在寻找 MCP 爱好者和分布式系统专家来参与讨论、分解我们的方法或做出贡献。  注册表： 我们在这里开源了 MCP 注册表：github.com/mcpmessenger/mcp-registry 堆栈： MCP， Kafka、Python/Node、TS 问题：我们需要关注编排逻辑。如果您处理过高扇出工具调用或复杂的消息路由，我们希望您能提供反馈。  请随意加注星号、分叉，或者告诉我们为什么我们的 Kafka 实现会失败。   由   提交/u/Ok-Priority35   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pz0wx6/tackling_the_norchestration_problem_how_do_we/</guid>
      <pubDate>Mon, 29 Dec 2025 22:54:28 GMT</pubDate>
    </item>
    <item>
      <title>一件事件、洋葱科技债务和裁员——事后分析来衡量指标问题</title>
      <link>https://www.reddit.com/r/programming/comments/1pyxrce/one_incident_onion_tech_debt_and_layoffs/</link>
      <description><![CDATA[ 由   提交/u/IndividualSecret1   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyxrce/one_incident_onion_tech_debt_and_layoffs/</guid>
      <pubDate>Mon, 29 Dec 2025 20:50:30 GMT</pubDate>
    </item>
    <item>
      <title>MIT Battlecode（编程竞赛）1周后开始！</title>
      <link>https://www.reddit.com/r/programming/comments/1pyx095/mit_battlecode_programming_competition_starts_in/</link>
      <description><![CDATA[Battlecode 是一款实时策略游戏，您将使用博弈论、寻路和分布式算法来建立一支机器人自主团队，并击败对手。 欢迎任何人以 1-4 人的团队形式参赛，争夺2 万美元奖金池，顶尖团队将获得有保证的实习机会与我们的白金赞助商，Amplitude！排名前 16 的学生团队还将免费飞往 MIT 参加 1 月 31 日的决赛。 除了基本的编程技能之外，不需要任何经验！机器人是用 Java 和/或 Python 编写的，但我们推荐使用 Java。我们将引导您了解创建第一个机器人的基础知识以及战胜其他玩家的高级策略。比赛附有将在 YouTube 上直播的讲座（但您也可以亲自参加麻省理工学院的讲座！）。 Battlecode 2026 将于 2026 年 1 月 5 日至 31 日举行。参与就是您想要的承诺（通常每周几个小时）！ 您可以在 battlecode.org/about 并在 play.battlecode.org/register 注册。 欢迎在此帖子中提问；我们会尽力解答！与去年类似的帖子，但我们有一些更新（例如现在提供 Python！）:)   由   提交/u/battlecode-devs  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyx095/mit_battlecode_programming_competition_starts_in/</guid>
      <pubDate>Mon, 29 Dec 2025 20:21:11 GMT</pubDate>
    </item>
    <item>
      <title>Apache Spark 默认情况下并不“快”；当你正确使用它时它会很快</title>
      <link>https://www.reddit.com/r/programming/comments/1pyw5a2/apache_spark_isnt_fast_by_default_its_fast_when/</link>
      <description><![CDATA[Spark 被宣传为更快的 Hadoop 替代品，但大多数性能问题来自于它的使用方式，而不是引擎本身；糟糕的分区、不必要的洗牌、滥用缓存或将 Spark 视为 SQL 数据库。当您了解 Spark 的执行模型、内存行为以及它在现代数据架构中的实际位置时，真正的收益就会显现出来。  此细分解释了 Spark 的最擅长之处、团队在哪里出错，以及它在实践中与其他数据处理工具的比较：Apache Spark Spark 给您带来更多痛苦的原因是什么；性能调整或管道复杂性？   由   提交/u/netcommah  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyw5a2/apache_spark_isnt_fast_by_default_its_fast_when/</guid>
      <pubDate>Mon, 29 Dec 2025 19:48:34 GMT</pubDate>
    </item>
    <item>
      <title>解释了一致性哈希解决了什么问题及其工作原理。</title>
      <link>https://www.reddit.com/r/programming/comments/1pyvrbs/explained_what_problem_consistent_hashing_solves/</link>
      <description><![CDATA[网上有数千种资源可以解释它，但不知何故，即使人工智能也无法按照我想要的方式解释它。  所以我试图阐明分布式系统中的这种基本算法是如何工作的。  我不是老师，但我希望这至少能帮助一些正在开始系统设计之旅的人。    由   提交/u/Comfortable-Fan-580   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyvrbs/explained_what_problem_consistent_hashing_solves/</guid>
      <pubDate>Mon, 29 Dec 2025 19:34:11 GMT</pubDate>
    </item>
    <item>
      <title>39C3：GnuPG 和其他加密工具中的多个漏洞</title>
      <link>https://www.reddit.com/r/programming/comments/1pytzea/39c3_multiple_vulnerabilities_in_gnupg_and_other/</link>
      <description><![CDATA[漏洞列表 演示视频点播 YouTube 重新托管（由作者提供）   由   提交 /u/LordAlfredo   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pytzea/39c3_multiple_vulnerabilities_in_gnupg_and_other/</guid>
      <pubDate>Mon, 29 Dec 2025 18:28:50 GMT</pubDate>
    </item>
    <item>
      <title>robots.txt 的兴衰</title>
      <link>https://www.reddit.com/r/programming/comments/1pytqia/the_rise_and_fall_of_robotstxt/</link>
      <description><![CDATA[ 由   提交 /u/TabCompletion   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pytqia/the_rise_and_fall_of_robotstxt/</guid>
      <pubDate>Mon, 29 Dec 2025 18:19:39 GMT</pubDate>
    </item>
    <item>
      <title>花了 3 个小时调试失败的 Stripe webhook。构建了这个工具，这样您就不必这样做了。</title>
      <link>https://www.reddit.com/r/programming/comments/1pyshlx/spent_3_hours_debugging_a_failed_stripe_webhook/</link>
      <description><![CDATA[Webhooks 非常有用，直到失败为止。然后调试就变成了一场噩梦： ❌ 看不到服务正在发送的内容 ❌ 本地主机隧道增加了复杂性 ❌ 没有简单的方法来重放请求 ❌ 签名验证错误很神秘 我构建了 Webhook 调试器 &amp;记录器来解决这个问题。它是一个 Apify Actor（无服务器），充当具有完全可观察性的 Webhook 端点。 ✨ v2.7.0“企业套件”中的新增功能：  • 低于 10 毫秒的开销（Apify 待机模式）⚡ • CIDR IP 白名单和 CIDR IP 白名单承载令牌安全 • 敏感标头屏蔽（身份验证/密钥清理） • 立即生成公共 Webhook URL • 捕获每个传入请求（GET、POST 等） • 显示原始标头、正文、查询参数、IP 地址 • 用于实时监控的实时 SSE 流式传输 • 以编程方式进行 /replay API重新发送请求 • JSON 模式验证以捕获格式错误的负载 • 自定义状态代码和延迟模拟• 将日志导出为JSON 或CSV 我为什么构建它： 传统工具（如ngrok）解决了本地主机暴露问题，但不提供Webhook 调试所需的可观察性。您仍然无法查看原始请求数据、重放测试请求或自动验证架构。 此工具弥补了这一差距。它针对调试 Stripe、GitHub、Shopify 和 Zapier 集成的开发人员进行了优化。 定价：每捕获 1,000 个 Webhook 10 美元。无需订阅，按需付费。 技术堆栈： Node.js、Apify SDK、服务器发送事件 查看：https://apify.com/ar27111994/webhook-debugger-logger 打开反馈和功能请求！   由   提交/u/ar27111994  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyshlx/spent_3_hours_debugging_a_failed_stripe_webhook/</guid>
      <pubDate>Mon, 29 Dec 2025 17:34:42 GMT</pubDate>
    </item>
    <item>
      <title>云 FinOps 不会“意外”失控：它们就是这样设计的</title>
      <link>https://www.reddit.com/r/programming/comments/1pyrjai/cloud_finops_dont_accidentally_get_out_of_control/</link>
      <description><![CDATA[大多数云成本问题并非源于错误的决策，而是源于缺乏所有权。团队交付速度很快，环境倍增，突然之间没有人知道哪些工作负载很重要，哪些工作负载可以缩减，或者谁负责账单。 FinOps 并不是盲目削减成本，而是盲目削减成本。这是为了给工程、财务和领导层提供相同的可见性，因此权衡是有意的，而不是被动的。 这篇文章很好地分解了 FinOps 在真正的云团队中的实际工作方式，而不是将其变成财务讲座：云 FinOps 好奇：在您的组织中什么更难：成本可见性或让团队在他们拥有后立即关心是吗？   由   提交/u/netcommah  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pyrjai/cloud_finops_dont_accidentally_get_out_of_control/</guid>
      <pubDate>Mon, 29 Dec 2025 16:59:52 GMT</pubDate>
    </item>
    <item>
      <title>我们来做个游戏吧！ 368：团队名称</title>
      <link>https://www.reddit.com/r/programming/comments/1pypdy5/lets_make_a_game_368_team_names/</link>
      <description><![CDATA[ 由   提交/u/apeloverage  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pypdy5/lets_make_a_game_368_team_names/</guid>
      <pubDate>Mon, 29 Dec 2025 15:38:26 GMT</pubDate>
    </item>
    <item>
      <title>当你在 Golang 中将 NAN 转换为 uint 时会发生什么</title>
      <link>https://www.reddit.com/r/programming/comments/1pynflx/what_happens_when_you_convert_a_nan_to_uint_in/</link>
      <description><![CDATA[ 由   提交/u/Sakshamarya   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pynflx/what_happens_when_you_convert_a_nan_to_uint_in/</guid>
      <pubDate>Mon, 29 Dec 2025 14:19:25 GMT</pubDate>
    </item>
    </channel>
</rss>
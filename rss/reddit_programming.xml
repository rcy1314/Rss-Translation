<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 18 Dec 2025 09:32:38 GMT</lastBuildDate>
    <item>
      <title>AI 有助于加快交付速度，但产生的错误数量却增加了 1.7 倍</title>
      <link>https://www.reddit.com/r/programming/comments/1ppm5vd/ai_helps_ship_faster_but_it_produces_17_more_bugs/</link>
      <description><![CDATA[ 由   提交/u/rag1987  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppm5vd/ai_helps_ship_faster_but_it_produces_17_more_bugs/</guid>
      <pubDate>Thu, 18 Dec 2025 08:55:31 GMT</pubDate>
    </item>
    <item>
      <title>编写一个小型字节码虚拟机教会了我如何调试长时间运行的程序</title>
      <link>https://www.reddit.com/r/programming/comments/1pplwnm/what_writing_a_tiny_bytecode_vm_taught_me_about/</link>
      <description><![CDATA[在出于学习目的开发小型字节码虚拟机时，我遇到了一个令我惊讶的问题：只有当运行时保持“活动”一段时间（循环、计时器、简单游戏）时，短程序中不可见的错误才会变得明显。 一个例子是连续运行的类似 Pong 的循环。它暴露了：  由于推入/弹出路径不匹配而导致堆栈的微妙增长 未正确展开状态的错误处理路径 如何记录每条指令比单步执行源代码有用  最有帮助的不是添加更多语言功能，而是：  以明确定义的方式转储虚拟机状态（堆栈、帧、指令指针）  在迭代之间区分转储以发现偏差 将虚拟机视为长期运行的系统而不是脚本运行程序  对我来说，即使程序本身很微不足道，连续程序对于运行时来说是比一次性脚本更好的压力测试。 我很好奇：  您使用哪些小程序消除运行时或解释器错误？ 对于此类工作，您是否发现虚拟机级工具比源代码级调试更有用？  （有意省略实现细节 - 这是关于调试方法而不是特定项目。）   由   提交 /u/Imaginary-Pound-1729   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pplwnm/what_writing_a_tiny_bytecode_vm_taught_me_about/</guid>
      <pubDate>Thu, 18 Dec 2025 08:37:59 GMT</pubDate>
    </item>
    <item>
      <title>两年前我退出编程并回归。这是我精疲力竭时的旧视频，我想比较从那以后事情发生了怎样的变化。</title>
      <link>https://www.reddit.com/r/programming/comments/1pplocn/i_quit_programming_2_years_ago_and_returned_this/</link>
      <description><![CDATA[两年前，我制作了一个关于如何放弃编程的视频。 2023 年，我厌倦了编程（倦怠），并制作了一个有关该经历的视频。但后来，在处理完倦怠之后，我变得更加坚强，所以我将视频设为私有。 现在我再次将其公开，我只是想看看它与今天相比如何。 https://www.youtube.com/watch?v=gY35df_lOsk 在那段时间里，我预测情况会变得多么糟糕，面试会变得越来越难。我仍然是一名全职程序员，我也开设编程课程。即使在 2022 年，我也知道这将会到来，因为自 2022 年以来，在 ChatGPT 发布和埃隆·马斯克大规模解雇之后，这就是导致编程工作现状的原因。公司意识到他们可以用更少的人做更多的事情，因为大多数员工什么都不做。这对我们影响最大。 但到了 2025 年，我什至不再编写代码了。我小心翼翼地使用人工智能。而且很多人认为 AI 是微软的副驾驶，这与 Cursor 相比确实很糟糕。如果你想用人工智能做任何好事，只需使用光标即可。并学习如何使用光标，如何为其提供正确的上下文，否则它将创建一个黑匣子。现在我正在从事一个由 5 个程序员曾经做过的项目，而我一个人的表现就超过了他们（他们不再从事同一个项目了）。他们花了几个月的时间来实现功能。如今，人工智能只需获取上下文或架构，就可以自行实现功能。仍然必须由经验丰富的程序员监督。 那么，只是想知道您对 2025 年编程状况的看法吗？   由   提交/u/KwonDarko  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pplocn/i_quit_programming_2_years_ago_and_returned_this/</guid>
      <pubDate>Thu, 18 Dec 2025 08:21:58 GMT</pubDate>
    </item>
    <item>
      <title>Claude Code 如何验证请求</title>
      <link>https://www.reddit.com/r/programming/comments/1ppj8bn/how_claude_code_authenticates_requests/</link>
      <description><![CDATA[ 由   提交 /u/-cat-father   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppj8bn/how_claude_code_authenticates_requests/</guid>
      <pubDate>Thu, 18 Dec 2025 05:48:38 GMT</pubDate>
    </item>
    <item>
      <title>优化我的游戏，使其在 Potato 上运行</title>
      <link>https://www.reddit.com/r/programming/comments/1ppik39/optimizing_my_game_so_it_runs_on_a_potato/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppik39/optimizing_my_game_so_it_runs_on_a_potato/</guid>
      <pubDate>Thu, 18 Dec 2025 05:11:05 GMT</pubDate>
    </item>
    <item>
      <title>Linux 内核 Rust 代码发现第一个 CVE 漏洞</title>
      <link>https://www.reddit.com/r/programming/comments/1ppfmyo/linux_kernel_rust_code_sees_its_first_cve/</link>
      <description><![CDATA[ 由   提交/u/peripateticman2026   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppfmyo/linux_kernel_rust_code_sees_its_first_cve/</guid>
      <pubDate>Thu, 18 Dec 2025 02:38:25 GMT</pubDate>
    </item>
    <item>
      <title>作为工程师或工程领导者如何开始公开演讲</title>
      <link>https://www.reddit.com/r/programming/comments/1ppfjiz/how_to_start_with_public_speaking_as_an_engineer/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppfjiz/how_to_start_with_public_speaking_as_an_engineer/</guid>
      <pubDate>Thu, 18 Dec 2025 02:33:38 GMT</pubDate>
    </item>
    <item>
      <title>Greptile 发布 2025 年人工智能编码现状报告</title>
      <link>https://www.reddit.com/r/programming/comments/1ppexvk/greptile_publishes_their_state_of_ai_coding_2025/</link>
      <description><![CDATA[Greptile 是一家每月对 2000 家公司的 10 亿行代码进行 AI 代码审查的公司，该公司发布了一些有关他们处理过的代码的指标。：  * 每个开发人员的代码行数在 2025 年从 4,450 行增长到 7,839 行。 * 从 3 月份到 2025 年，PR 大小中位数增加了 33% 2025 年 11 月，每个 PR 更改的行数从 57 行增加到 76 行。  * 中型团队（6-15 名开发人员）将每位开发人员的产出从 7,005 行增加到 13,227 行。 ^随着 PR 变得更加密集，每个文件的中位数行数从 18 行增加到 22 行。   由   提交 /u/ humanquester   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppexvk/greptile_publishes_their_state_of_ai_coding_2025/</guid>
      <pubDate>Thu, 18 Dec 2025 02:04:34 GMT</pubDate>
    </item>
    <item>
      <title>30 年 <br> 标签</title>
      <link>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</link>
      <description><![CDATA[ 由   提交/u/brokePlusPlusCoder  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</guid>
      <pubDate>Thu, 18 Dec 2025 01:45:40 GMT</pubDate>
    </item>
    <item>
      <title>MCP值得大肆宣传吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</guid>
      <pubDate>Thu, 18 Dec 2025 00:07:50 GMT</pubDate>
    </item>
    <item>
      <title>为什么更便宜的推理很少减少计算需求（系统角度）</title>
      <link>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</link>
      <description><![CDATA[在过去的几年里，推理效率得到了显着提高：更好的硬件、更严格的内核、量化、推测性解码和类似技术都在很大程度上降低了每个令牌的成本。 尽管如此，总推理计算需求仍在不断上升。 这篇文章认为，原因不仅仅是反弹效应，而是一个经常未被提及的更深层次的系统假设：大模型前向传递对于每个请求都是强制性的。 大多数“推理优化”工作都接受这一前提，并专注于使每个传递更便宜或更快。这可靠地降低了边际成本，从而吸引更多的使用并吸收收益。 另一种框架是将昂贵的推理视为有条件的和授权的，而不是自动的。在许多实际系统中，目标不是开放式生成，而是解决受限决策（路由与升级、允许与阻止、重用与重新计算）。在这些情况下，并不总是需要完整的前向传递才能产生正确的结果。 从这个角度来看，提前退出、路由、缓存、小模型过滤器和非 LLM 逻辑等技术是更广泛原则的示例：将避免执行作为一流的设计目标，而不是加速不可避免的执行。 这篇文章探讨了这种重构如何改变推理的经济性，为什么它会改变需求而不是改变需求。只是改变它，并且它的限制仍然适用。   由   提交 /u/anima-core   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</guid>
      <pubDate>Wed, 17 Dec 2025 23:32:39 GMT</pubDate>
    </item>
    <item>
      <title>Rust Linux 内核代码中发现安全漏洞。</title>
      <link>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</guid>
      <pubDate>Wed, 17 Dec 2025 22:43:09 GMT</pubDate>
    </item>
    <item>
      <title>为跨 Win32 和 Win64 的纯汇编框架设计稳定的 ABI</title>
      <link>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</link>
      <description><![CDATA[我一直在探索如何在纯汇编中编写重要的软件，而不需要跨架构复制逻辑。 主要挑战之一是规范逻辑 ABI 层背后截然不同的 Win32 和 Win64 调用约定。 关键设计点： - 核心代码从不直接引用架构寄存器 - 逻辑参数/返回约定通过宏映射到每个平台 - 堆栈集中执行纪律和寄存器保存规则 - 这允许在 x86 和 x86-64 上构建相同的核心逻辑 这种方法使小型 ASCII/2D 游戏框架能够跨架构共享所有核心逻辑，而无需条件代码。 我编写了设计并在以下位置提供了完整的源示例：GitHub.com/Markusdulree-art/GLYPH-FRAMEWORK 我很好奇其他人是如何实现 ABI 标准化的。   由   提交/u/Easy-Zone-4141   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</guid>
      <pubDate>Wed, 17 Dec 2025 21:25:15 GMT</pubDate>
    </item>
    <item>
      <title>PR 不足以调试代理编写的代码</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</link>
      <description><![CDATA[在我作为软件工程师的经验中，我们经常按以下顺序解决生产错误：  随叫随到通知 Sentry、datadog、PagerDuty 中存在问题 我们找出它与哪个 PR 相关 进行 Git 责备以找出 PR 的作者 告诉他们修复它并更新单元测试  尽管如此，这里的关键问题是 PR 会告诉您错误发生在哪里。 使用代理代码，它们通常不会告诉您代理为何进行更改。 使用代理编码，单个 PR 现在的最终输出是：  提示 + 修订 错误/陈旧的存储库上下文 静默失败的工具调用（身份验证/超时） 约束不匹配（不强制执行“请勿触摸计费”）  因此，我开始认为事件响应需要“代理可追溯性”：  提示/上下文引用 工具调用时间线/结果 关键决策点 映射对会话事件的编辑  本质上，为了让我们更好地调试，我们需要对代理以某种方式开发的原因有一个根本的推理，而不仅仅是代码的输出。 编辑：打字错误：x 更新：步骤3意味着git的责任，而不是谴责个人。   由   提交 /u/brandon-i   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</guid>
      <pubDate>Wed, 17 Dec 2025 19:39:47 GMT</pubDate>
    </item>
    <item>
      <title>当实现一种小型解释语言时令我惊讶的是（解析是简单的部分）</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</link>
      <description><![CDATA[在实现小型解释语言作为学习练习时，我预计解析是最难的部分。事实证明，它是更简单的组件之一。 花费最多时间的部分是错误诊断、执行语义和控制流边缘情况，即使语法非常小。 在实现过程中突出的一些事情： 1。错误处理在早期设计中占主导地位 最小的语法仍然会产生许多失败模式。 需要有意义的错误：  保留标记范围（行/列范围） 延迟一些检查直到语义分析 报告预期的结构而不是一般的失败  没有这个，语言在技术上是正确的，但无法使用。 2. Pratt 解析简化了语法，而不是语义 使用 Pratt 解析器使表达式解析变得紧凑和灵活，但是：  语句边界 作用域规则 函数返回与程序终止  无论解析器是否简单，都需要显式的 VM 级处理。 3.基于堆栈的虚拟机很快就会暴露出设计缺陷 即使是基本的虚拟机也被迫做出以下决策：  调用帧与全局状态 函数如何在不停止执行的情况下返回 导入如何影响运行时状态  这些问题只有在运行重要程序时才会出现。 要点 构建“真实”程序发现了设计问题比单元测试快得多。大多数复杂性不是来自功能，而是来自在边缘情况下定义正确的行为。 如果有人想深入了解细节，我在这里记录了完整的实现（词法分析器→解析器→字节码→VM）。单击链接。   由   提交/u/Imaginary-Pound-1729   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</guid>
      <pubDate>Wed, 17 Dec 2025 19:25:51 GMT</pubDate>
    </item>
    </channel>
</rss>
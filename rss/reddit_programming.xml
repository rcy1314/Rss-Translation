<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sun, 18 Jan 2026 06:38:39 GMT</lastBuildDate>
    <item>
      <title>根据 DB-Engines 的排名，MySQL 的受欢迎程度开始大幅下滑，这一趋势可能会在 2026 年加速。</title>
      <link>https://www.reddit.com/r/programming/comments/1qg0p6p/mysqls_popularity_as_ranked_by_dbengines_started/</link>
      <description><![CDATA[ 由   提交/u/thehashimwarren  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qg0p6p/mysqls_popularity_as_ranked_by_dbengines_started/</guid>
      <pubDate>Sun, 18 Jan 2026 06:04:01 GMT</pubDate>
    </item>
    <item>
      <title>出于好奇，使用 MobSF 测试了随机 APK</title>
      <link>https://www.reddit.com/r/programming/comments/1qg0i7h/tested_a_random_apk_with_mobsf_out_of_curiosity/</link>
      <description><![CDATA[大家好， 免责声明：我是一名 Flutter 开发人员，而不是安全专家。这纯粹是一个对移动安全工具感到好奇的人的学习实验。如果我弄乱了术语或遗漏了一些明显的内容，请纠正我 - 这就是我发布此内容的真正原因。 我已经使用应用程序 APK 2 年了（不在 Playstore 上）。对移动安全工具感到好奇，所以我使用 MobSF 对其进行了扫描。 设置（需要 2 分钟）： docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf  安全得分：44/100 主要发现：  调试证书 - 使用 Android 的默认调试密钥签名。任何人都可以修改并重新签名。 启用明文流量 - 通过 HTTP 进行流式传输已有 2 年了。我的 ISP 看到了一切。 粗略权限： GET_INSTALLED_APPLICATIONS - 扫描我安装的应用程序 RECORD_AUDIO - 应用程序中不存在语音搜索   MobSF 非常易于使用。如果您从未扫描过自己的应用，请尝试一下。 对于那些想要了解更多详细信息的人，我在 Medium 上写了一篇带有屏幕截图的分步文章。如果您有兴趣，可以在我的个人资料中找到该链接。不推销任何东西 - 我不是 Medium 会员，所以我不会从中赚钱。只是分享给想要了解更多流程的人。   由   提交 /u/night-alien   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qg0i7h/tested_a_random_apk_with_mobsf_out_of_curiosity/</guid>
      <pubDate>Sun, 18 Jan 2026 05:53:42 GMT</pubDate>
    </item>
    <item>
      <title>Linus 可能会震动代码，但这并不能使其成为最佳实践</title>
      <link>https://www.reddit.com/r/programming/comments/1qfzyq8/linus_may_vibe_code_but_that_doesnt_make_it_best/</link>
      <description><![CDATA[ 由   提交 /u/Weekly-Ad7131   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfzyq8/linus_may_vibe_code_but_that_doesnt_make_it_best/</guid>
      <pubDate>Sun, 18 Jan 2026 05:25:02 GMT</pubDate>
    </item>
    <item>
      <title>关于后端托管的问题</title>
      <link>https://www.reddit.com/r/programming/comments/1qfytya/question_for_backend_hosting/</link>
      <description><![CDATA[大家好，美好的一天。我想询问有关在哪里托管 FastAPI 后端的建议？我专门寻找一个免费选项，因为这是我们的顶点项目。 我之前尝试过使用渲染，但我发现响应时间非常慢（通常需要几分钟才能在前端加载）。任何建议将不胜感激。谢谢！   由   提交/u/Suitable_Ad_1266   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfytya/question_for_backend_hosting/</guid>
      <pubDate>Sun, 18 Jan 2026 04:27:39 GMT</pubDate>
    </item>
    <item>
      <title>jQuery 4.0 发布</title>
      <link>https://www.reddit.com/r/programming/comments/1qfxo89/jquery_40_released/</link>
      <description><![CDATA[ 由   提交/u/curiousdannii  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfxo89/jquery_40_released/</guid>
      <pubDate>Sun, 18 Jan 2026 03:31:22 GMT</pubDate>
    </item>
    <item>
      <title>前沿部署工程师正在重塑软件职业</title>
      <link>https://www.reddit.com/r/programming/comments/1qfts7m/the_forward_deployed_engineer_is_reshaping/</link>
      <description><![CDATA[Palantir 诞生的职位如何成为人工智能初创公司中最热门的工作，世界其他地方如何流行，以及它对传统工程师意味着什么   由   提交 /u/jpcaparas   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfts7m/the_forward_deployed_engineer_is_reshaping/</guid>
      <pubDate>Sun, 18 Jan 2026 00:32:04 GMT</pubDate>
    </item>
    <item>
      <title>谷歌反重力有多好？</title>
      <link>https://www.reddit.com/r/programming/comments/1qfpxfh/how_good_is_google_antigravity/</link>
      <description><![CDATA[我一开始使用 Visual Studio Code，但后来开始使用 Cursor。但既然反重力已经实现，你认为值得开始使用它吗？或者两者都有？您对此有何看法？   由   提交/u/ahorify_dev  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfpxfh/how_good_is_google_antigravity/</guid>
      <pubDate>Sat, 17 Jan 2026 21:49:37 GMT</pubDate>
    </item>
    <item>
      <title>- YouTube</title>
      <link>https://www.reddit.com/r/programming/comments/1qfp3h9/youtube/</link>
      <description><![CDATA[ 由   提交/u/ulyanovv  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfp3h9/youtube/</guid>
      <pubDate>Sat, 17 Jan 2026 21:16:07 GMT</pubDate>
    </item>
    <item>
      <title>构建与提供商无关的编码代理</title>
      <link>https://www.reddit.com/r/programming/comments/1qfnk7n/building_a_provideragnostic_coding_agent/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfnk7n/building_a_provideragnostic_coding_agent/</guid>
      <pubDate>Sat, 17 Jan 2026 20:14:31 GMT</pubDate>
    </item>
    <item>
      <title>如何使用 Rust 和 WebAssembly 在 Freenet 上构建去中心化 Web 应用程序</title>
      <link>https://www.reddit.com/r/programming/comments/1qflgvq/how_to_build_decentralized_web_apps_on_freenet/</link>
      <description><![CDATA[ 由   提交/u/sanity  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qflgvq/how_to_build_decentralized_web_apps_on_freenet/</guid>
      <pubDate>Sat, 17 Jan 2026 18:52:33 GMT</pubDate>
    </item>
    <item>
      <title>用 Rust 设计列式数据库：有关 io_uring、SIMD 的课程以及我避免使用 Async/Await 的原因</title>
      <link>https://www.reddit.com/r/programming/comments/1qfkijn/engineering_a_columnar_database_in_rust_lessons/</link>
      <description><![CDATA[我最近发布了 Frigatebird 的核心引擎，这是一个从头开始构建的 OLAP（列式）数据库。在构建它的过程中，我做出了一些违反“标准”的架构决策。 Rust 网络/系统路径。我想分享这些选择的基本原理和性能影响。 1.为什么我放弃 Async/Await 而选择自定义运行时 Rust 中的标准建议是“只使用 Tokio”。然而，通用异步运行时主要是为具有许多空闲连接的 IO 绑定任务而设计的。在数据库执行管道中，任务通常占用大量 CPU（扫描/过滤压缩页面）。 我发现将大量计算与标准异步执行器混合会导致不可预测的调度延迟。相反，我实现了一个Morsel-Driven Parallelism模型（受到DuckDB/Hyper的启发）：  查询被分解为“morsels”。 （固定大小的行组）。 工作线程使用无锁工作窃取，而不是中央调度程序。 查询作业保存一个 AtomicUsize 计数器。线程竞相增加它（CAS），有效地“声明”线程。管道的下一步。 这可以保持 CPU 核心固定并最大化指令缓存局部性，因为线程倾向于坚持特定的逻辑循环（扫描与过滤）。  2.批处理 io_uring 与标准系统调用 对于 WAL（预写日志），fsync 延迟是杀手。我构建了一个自定义存储引擎（“Walrus”）来利用 Linux 的 io_uring。  编写者不是逐个发出 pwrite 系统调用，而是在用户空间中构造了一个包含约 2,000 个条目的提交队列。 它发出一个 Submit_and_wait 系统调用来刷新所有条目。 这显着减少了上下文切换开销，使引擎达到饱和。单线程上的 NVMe 带宽。  3. “自旋锁”分配器这是风险最大的决定。标准操作系统互斥体 (pthread_mutex) 使线程进入睡眠状态，耗费微秒。  对于磁盘块分配器，我实现了自定义 AtomicBool 自旋锁。 它在紧密循环 (std::hint::spin_loop()) 中旋转纳秒。 权衡：如果操作系统抢占持有锁的线程，系统停顿。但由于关键部分只是简单的整数数学（计算偏移量），因此它的执行速度比操作系统调度程序量子更快，这使得它在统计上安全且速度极快。  4。零拷贝序列化我使用rkyv而不是serde。 Serde 很棒，但它通常涉及反序列化步骤（将字节解析为结构）。 rkyv 保证内存中的表示与磁盘上的表示相同，只需在原始缓冲区上投射指针即可实现真正的零复制访问。 我很好奇这里的其他人是否在 CPU 限制的上下文中与 Tokio 遇到了类似的问题，或者我只是未能正确调整它？   由   提交/u/Ok_Marionberry8922   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfkijn/engineering_a_columnar_database_in_rust_lessons/</guid>
      <pubDate>Sat, 17 Jan 2026 18:16:44 GMT</pubDate>
    </item>
    <item>
      <title>初级开发者的消失：2026年如何开启职业生涯</title>
      <link>https://www.reddit.com/r/programming/comments/1qfjtn2/the_disappearance_of_the_junior_developer_how_to/</link>
      <description><![CDATA[ 由   提交/u/RevillWeb  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfjtn2/the_disappearance_of_the_junior_developer_how_to/</guid>
      <pubDate>Sat, 17 Jan 2026 17:51:02 GMT</pubDate>
    </item>
    <item>
      <title>MindFry：一个开源数据库，可以忘记、强化和抑制生物记忆等数据</title>
      <link>https://www.reddit.com/r/programming/comments/1qfjptb/mindfry_an_opensource_database_that_forgets/</link>
      <description><![CDATA[ 由   提交/u/laphilosophia   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfjptb/mindfry_an_opensource_database_that_forgets/</guid>
      <pubDate>Sat, 17 Jan 2026 17:46:55 GMT</pubDate>
    </item>
    <item>
      <title>Vibe 编码的二阶和三阶效应</title>
      <link>https://www.reddit.com/r/programming/comments/1qfjjbk/second_and_third_order_effects_of_vibe_coding/</link>
      <description><![CDATA[未来对每个人来说都将更具创业精神。我在未来 6-12 个月内看到了氛围编码的机会。   由   提交/u/EnterpriseVibeCode   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfjjbk/second_and_third_order_effects_of_vibe_coding/</guid>
      <pubDate>Sat, 17 Jan 2026 17:40:05 GMT</pubDate>
    </item>
    <item>
      <title>设计键值存储</title>
      <link>https://www.reddit.com/r/programming/comments/1qfjeos/designing_a_keyvalue_store/</link>
      <description><![CDATA[ 由   提交 /u/okutac   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qfjeos/designing_a_keyvalue_store/</guid>
      <pubDate>Sat, 17 Jan 2026 17:35:15 GMT</pubDate>
    </item>
    </channel>
</rss>
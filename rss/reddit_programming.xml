<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 18 Dec 2025 06:40:09 GMT</lastBuildDate>
    <item>
      <title>Claude Code 如何验证请求</title>
      <link>https://www.reddit.com/r/programming/comments/1ppj8bn/how_claude_code_authenticates_requests/</link>
      <description><![CDATA[ 由   提交 /u/-cat-father   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppj8bn/how_claude_code_authenticates_requests/</guid>
      <pubDate>Thu, 18 Dec 2025 05:48:38 GMT</pubDate>
    </item>
    <item>
      <title>优化我的游戏，使其在 Potato 上运行</title>
      <link>https://www.reddit.com/r/programming/comments/1ppik39/optimizing_my_game_so_it_runs_on_a_potato/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppik39/optimizing_my_game_so_it_runs_on_a_potato/</guid>
      <pubDate>Thu, 18 Dec 2025 05:11:05 GMT</pubDate>
    </item>
    <item>
      <title>Linux 内核 Rust 代码发现第一个 CVE 漏洞</title>
      <link>https://www.reddit.com/r/programming/comments/1ppfmyo/linux_kernel_rust_code_sees_its_first_cve/</link>
      <description><![CDATA[ 由   提交/u/peripateticman2026   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppfmyo/linux_kernel_rust_code_sees_its_first_cve/</guid>
      <pubDate>Thu, 18 Dec 2025 02:38:25 GMT</pubDate>
    </item>
    <item>
      <title>作为工程师或工程领导者如何开始公开演讲</title>
      <link>https://www.reddit.com/r/programming/comments/1ppfjiz/how_to_start_with_public_speaking_as_an_engineer/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppfjiz/how_to_start_with_public_speaking_as_an_engineer/</guid>
      <pubDate>Thu, 18 Dec 2025 02:33:38 GMT</pubDate>
    </item>
    <item>
      <title>Greptile 发布 2025 年人工智能编码现状报告</title>
      <link>https://www.reddit.com/r/programming/comments/1ppexvk/greptile_publishes_their_state_of_ai_coding_2025/</link>
      <description><![CDATA[Greptile 是一家每月对 2000 家公司的 10 亿行代码进行 AI 代码审查的公司，该公司发布了一些有关他们处理过的代码的指标。：  * 每个开发人员的代码行数在 2025 年从 4,450 行增长到 7,839 行。 * 从 3 月份到 2025 年，PR 大小中位数增加了 33% 2025 年 11 月，每个 PR 更改的行数从 57 行增加到 76 行。  * 中型团队（6-15 名开发人员）将每位开发人员的产出从 7,005 行增加到 13,227 行。 ^随着 PR 变得更加密集，每个文件的中位数行数从 18 行增加到 22 行。   由   提交 /u/ humanquester   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppexvk/greptile_publishes_their_state_of_ai_coding_2025/</guid>
      <pubDate>Thu, 18 Dec 2025 02:04:34 GMT</pubDate>
    </item>
    <item>
      <title>30 年 <br> 标签</title>
      <link>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</link>
      <description><![CDATA[ 由   提交/u/brokePlusPlusCoder  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</guid>
      <pubDate>Thu, 18 Dec 2025 01:45:40 GMT</pubDate>
    </item>
    <item>
      <title>MCP值得大肆宣传吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</guid>
      <pubDate>Thu, 18 Dec 2025 00:07:50 GMT</pubDate>
    </item>
    <item>
      <title>为什么更便宜的推理很少减少计算需求（系统角度）</title>
      <link>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</link>
      <description><![CDATA[在过去的几年里，推理效率得到了显着提高：更好的硬件、更严格的内核、量化、推测性解码和类似技术都在很大程度上降低了每个令牌的成本。 尽管如此，总推理计算需求仍在不断上升。 这篇文章认为，原因不仅仅是反弹效应，而是一个经常未被提及的更深层次的系统假设：大模型前向传递对于每个请求都是强制性的。 大多数“推理优化”工作都接受这一前提，并专注于使每个传递更便宜或更快。这可靠地降低了边际成本，从而吸引更多的使用并吸收收益。 另一种框架是将昂贵的推理视为有条件的和授权的，而不是自动的。在许多实际系统中，目标不是开放式生成，而是解决受限决策（路由与升级、允许与阻止、重用与重新计算）。在这些情况下，并不总是需要完整的前向传递才能产生正确的结果。 从这个角度来看，提前退出、路由、缓存、小模型过滤器和非 LLM 逻辑等技术是更广泛原则的示例：将避免执行作为一流的设计目标，而不是加速不可避免的执行。 这篇文章探讨了这种重构如何改变推理的经济性，为什么它会改变需求而不是改变需求。只是改变它，并且它的限制仍然适用。   由   提交 /u/anima-core   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</guid>
      <pubDate>Wed, 17 Dec 2025 23:32:39 GMT</pubDate>
    </item>
    <item>
      <title>Rust Linux 内核代码中发现安全漏洞。</title>
      <link>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</guid>
      <pubDate>Wed, 17 Dec 2025 22:43:09 GMT</pubDate>
    </item>
    <item>
      <title>为跨 Win32 和 Win64 的纯汇编框架设计稳定的 ABI</title>
      <link>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</link>
      <description><![CDATA[我一直在探索如何在纯汇编中编写重要的软件，而不需要跨架构复制逻辑。 主要挑战之一是规范逻辑 ABI 层背后截然不同的 Win32 和 Win64 调用约定。 关键设计点： - 核心代码从不直接引用架构寄存器 - 逻辑参数/返回约定通过宏映射到每个平台 - 堆栈集中执行纪律和寄存器保存规则 - 这允许在 x86 和 x86-64 上构建相同的核心逻辑 这种方法使小型 ASCII/2D 游戏框架能够跨架构共享所有核心逻辑，而无需条件代码。 我编写了设计并在以下位置提供了完整的源示例：GitHub.com/Markusdulree-art/GLYPH-FRAMEWORK 我很好奇其他人是如何实现 ABI 标准化的。   由   提交/u/Easy-Zone-4141   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</guid>
      <pubDate>Wed, 17 Dec 2025 21:25:15 GMT</pubDate>
    </item>
    <item>
      <title>PR 不足以调试代理编写的代码</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</link>
      <description><![CDATA[在我作为软件工程师的经验中，我们经常按以下顺序解决生产错误：  随叫随到通知 Sentry、datadog、PagerDuty 中存在问题 我们找出它与哪个 PR 相关 进行 Git 责备以找出 PR 的作者 告诉他们修复它并更新单元测试  尽管如此，这里的关键问题是 PR 会告诉您错误发生在哪里。 使用代理代码，它们通常不会告诉您代理为何进行更改。 使用代理编码，单个 PR 现在的最终输出是：  提示 + 修订 错误/陈旧的存储库上下文 静默失败的工具调用（身份验证/超时） 约束不匹配（不强制执行“请勿触摸计费”）  因此，我开始认为事件响应需要“代理可追溯性”：  提示/上下文引用 工具调用时间线/结果 关键决策点 映射对会话事件的编辑  本质上，为了让我们更好地调试，我们需要对代理以某种方式开发的原因有一个根本的推理，而不仅仅是代码的输出。 编辑：打字错误：x 更新：步骤3意味着git的责任，而不是谴责个人。   由   提交 /u/brandon-i   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</guid>
      <pubDate>Wed, 17 Dec 2025 19:39:47 GMT</pubDate>
    </item>
    <item>
      <title>当实现一种小型解释语言时令我惊讶的是（解析是简单的部分）</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</link>
      <description><![CDATA[在实现小型解释语言作为学习练习时，我预计解析是最难的部分。事实证明，它是更简单的组件之一。 花费最多时间的部分是错误诊断、执行语义和控制流边缘情况，即使语法非常小。 在实现过程中突出的一些事情： 1。错误处理在早期设计中占主导地位 最小的语法仍然会产生许多失败模式。 需要有意义的错误：  保留标记范围（行/列范围） 延迟一些检查直到语义分析 报告预期的结构而不是一般的失败  没有这个，语言在技术上是正确的，但无法使用。 2. Pratt 解析简化了语法，而不是语义 使用 Pratt 解析器使表达式解析变得紧凑和灵活，但是：  语句边界 作用域规则 函数返回与程序终止  无论解析器是否简单，都需要显式的 VM 级处理。 3.基于堆栈的虚拟机很快就会暴露出设计缺陷 即使是基本的虚拟机也被迫做出以下决策：  调用帧与全局状态 函数如何在不停止执行的情况下返回 导入如何影响运行时状态  这些问题只有在运行重要程序时才会出现。 要点 构建“真实”程序发现了设计问题比单元测试快得多。大多数复杂性不是来自功能，而是来自在边缘情况下定义正确的行为。 如果有人想深入了解细节，我在这里记录了完整的实现（词法分析器→解析器→字节码→VM）。单击链接。   由   提交/u/Imaginary-Pound-1729   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</guid>
      <pubDate>Wed, 17 Dec 2025 19:25:51 GMT</pubDate>
    </item>
    <item>
      <title>这些年来我一直在错误地写环形缓冲区</title>
      <link>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</link>
      <description><![CDATA[ 由   提交/u/BrewedDoritos  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</guid>
      <pubDate>Wed, 17 Dec 2025 19:05:57 GMT</pubDate>
    </item>
    <item>
      <title>内联——终极优化</title>
      <link>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</link>
      <description><![CDATA[ 由   提交/u/emschwartz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</guid>
      <pubDate>Wed, 17 Dec 2025 16:46:28 GMT</pubDate>
    </item>
    <item>
      <title>Ruby 4.0 中的新增功能</title>
      <link>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</link>
      <description><![CDATA[ 由   提交 /u/nithinbekal   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</guid>
      <pubDate>Wed, 17 Dec 2025 16:40:48 GMT</pubDate>
    </item>
    </channel>
</rss>
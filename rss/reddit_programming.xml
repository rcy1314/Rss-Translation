<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 18 Dec 2025 01:56:09 GMT</lastBuildDate>
    <item>
      <title>30 年 <br> 标签</title>
      <link>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</link>
      <description><![CDATA[ 由   提交/u/brokePlusPlusCoder  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppejs9/30_years_of_br_tags/</guid>
      <pubDate>Thu, 18 Dec 2025 01:45:40 GMT</pubDate>
    </item>
    <item>
      <title>MCP值得大肆宣传吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppch19/is_mcp_worth_the_hype/</guid>
      <pubDate>Thu, 18 Dec 2025 00:07:50 GMT</pubDate>
    </item>
    <item>
      <title>为什么更便宜的推理很少减少计算需求（系统角度）</title>
      <link>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</link>
      <description><![CDATA[在过去的几年里，推理效率得到了显着提高：更好的硬件、更严格的内核、量化、推测性解码和类似技术都在很大程度上降低了每个令牌的成本。 尽管如此，总推理计算需求仍在不断上升。 这篇文章认为，原因不仅仅是反弹效应，而是一个经常未被提及的更深层次的系统假设：大模型前向传递对于每个请求都是强制性的。 大多数“推理优化”工作都接受这一前提，并专注于使每个传递更便宜或更快。这可靠地降低了边际成本，从而吸引更多的使用并吸收收益。 另一种框架是将昂贵的推理视为有条件的和授权的，而不是自动的。在许多实际系统中，目标不是开放式生成，而是解决受限决策（路由与升级、允许与阻止、重用与重新计算）。在这些情况下，并不总是需要完整的前向传递才能产生正确的结果。 从这个角度来看，提前退出、路由、缓存、小模型过滤器和非 LLM 逻辑等技术是更广泛原则的示例：将避免执行作为一流的设计目标，而不是加速不可避免的执行。 这篇文章探讨了这种重构如何改变推理的经济性，为什么它会改变需求而不是改变需求。只是改变它，并且它的限制仍然适用。   由   提交 /u/anima-core   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppbo3p/why_cheaper_inference_rarely_reduces_compute/</guid>
      <pubDate>Wed, 17 Dec 2025 23:32:39 GMT</pubDate>
    </item>
    <item>
      <title>Rust Linux 内核代码中发现安全漏洞。</title>
      <link>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ppai1u/security_vulnerability_found_in_rust_linux_kernel/</guid>
      <pubDate>Wed, 17 Dec 2025 22:43:09 GMT</pubDate>
    </item>
    <item>
      <title>为跨 Win32 和 Win64 的纯汇编框架设计稳定的 ABI</title>
      <link>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</link>
      <description><![CDATA[我一直在探索如何在纯汇编中编写重要的软件，而不需要跨架构复制逻辑。 主要挑战之一是规范逻辑 ABI 层背后截然不同的 Win32 和 Win64 调用约定。 关键设计点： - 核心代码从不直接引用架构寄存器 - 逻辑参数/返回约定通过宏映射到每个平台 - 堆栈集中执行纪律和寄存器保存规则 - 这允许在 x86 和 x86-64 上构建相同的核心逻辑 这种方法使小型 ASCII/2D 游戏框架能够跨架构共享所有核心逻辑，而无需条件代码。 我编写了设计并在以下位置提供了完整的源示例：GitHub.com/Markusdulree-art/GLYPH-FRAMEWORK 我很好奇其他人是如何实现 ABI 标准化的。   由   提交/u/Easy-Zone-4141   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp8kyy/designing_a_stable_abi_for_a_pureassembly/</guid>
      <pubDate>Wed, 17 Dec 2025 21:25:15 GMT</pubDate>
    </item>
    <item>
      <title>PR 不足以调试代理编写的代码</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</link>
      <description><![CDATA[在我作为软件工程师的经验中，我们经常按以下顺序解决生产错误：  随叫随到通知 Sentry、datadog、PagerDuty 中存在问题 我们找出它与哪个 PR 相关 进行 Git 责备以找出 PR 的作者 告诉他们修复它并更新单元测试  尽管如此，这里的关键问题是 PR 会告诉您错误发生在哪里。 使用代理代码，它们通常不会告诉您代理为何进行更改。 使用代理编码，单个 PR 现在的最终输出是：  提示 + 修订 错误/陈旧的存储库上下文 静默失败的工具调用（身份验证/超时） 约束不匹配（不强制执行“请勿触摸计费”）  因此，我开始认为事件响应需要“代理可追溯性”：  提示/上下文引用 工具调用时间线/结果 关键决策点 映射对会话事件的编辑  本质上，为了让我们更好地调试，我们需要对代理以某种方式开发的原因有一个根本的推理，而不仅仅是代码的输出。 编辑：打字错误：x 更新：步骤3意味着git的责任，而不是谴责个人。   由   提交 /u/brandon-i   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5wty/prs_arent_enough_to_debug_agentwritten_code/</guid>
      <pubDate>Wed, 17 Dec 2025 19:39:47 GMT</pubDate>
    </item>
    <item>
      <title>当实现一种小型解释语言时令我惊讶的是（解析是简单的部分）</title>
      <link>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</link>
      <description><![CDATA[在实现小型解释语言作为学习练习时，我预计解析是最难的部分。事实证明，它是更简单的组件之一。 花费最多时间的部分是错误诊断、执行语义和控制流边缘情况，即使语法非常小。 在实现过程中突出的一些事情： 1。错误处理在早期设计中占主导地位 最小的语法仍然会产生许多失败模式。 需要有意义的错误：  保留标记范围（行/列范围） 延迟一些检查直到语义分析 报告预期的结构而不是一般的失败  没有这个，语言在技术上是正确的，但无法使用。 2. Pratt 解析简化了语法，而不是语义 使用 Pratt 解析器使表达式解析变得紧凑和灵活，但是：  语句边界 作用域规则 函数返回与程序终止  无论解析器是否简单，都需要显式的 VM 级处理。 3.基于堆栈的虚拟机很快就会暴露出设计缺陷 即使是基本的虚拟机也被迫做出以下决策：  调用帧与全局状态 函数如何在不停止执行的情况下返回 导入如何影响运行时状态  这些问题只有在运行重要程序时才会出现。 要点 构建“真实”程序发现了设计问题比单元测试快得多。大多数复杂性不是来自功能，而是来自在边缘情况下定义正确的行为。 如果有人想深入了解细节，我在这里记录了完整的实现（词法分析器→解析器→字节码→VM）。单击链接。   由   提交/u/Imaginary-Pound-1729   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp5jyd/what_surprised_me_when_implementing_a_small/</guid>
      <pubDate>Wed, 17 Dec 2025 19:25:51 GMT</pubDate>
    </item>
    <item>
      <title>这些年来我一直在错误地写环形缓冲区</title>
      <link>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</link>
      <description><![CDATA[ 由   提交/u/BrewedDoritos  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp51kr/ive_been_writing_ring_buffers_wrong_all_these/</guid>
      <pubDate>Wed, 17 Dec 2025 19:05:57 GMT</pubDate>
    </item>
    <item>
      <title>内联——终极优化</title>
      <link>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</link>
      <description><![CDATA[ 由   提交/u/emschwartz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp1esr/inlining_the_ultimate_optimisation/</guid>
      <pubDate>Wed, 17 Dec 2025 16:46:28 GMT</pubDate>
    </item>
    <item>
      <title>Ruby 4.0 中的新增功能</title>
      <link>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</link>
      <description><![CDATA[ 由   提交 /u/nithinbekal   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp19ku/whats_new_in_ruby_40/</guid>
      <pubDate>Wed, 17 Dec 2025 16:40:48 GMT</pubDate>
    </item>
    <item>
      <title>TornadoVM 2.0 为 Java 带来自动 GPU 加速和 LLM 支持</title>
      <link>https://www.reddit.com/r/programming/comments/1pp129e/tornadovm_20_brings_automatic_gpu_acceleration/</link>
      <description><![CDATA[ 由   提交/u/benevanstech  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp129e/tornadovm_20_brings_automatic_gpu_acceleration/</guid>
      <pubDate>Wed, 17 Dec 2025 16:32:44 GMT</pubDate>
    </item>
    <item>
      <title>进一步优化我的 Java SwissTable：配置文件污染和 SWAR 探测</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0wg2/further_optimizing_my_java_swisstable_profile/</link>
      <description><![CDATA[大家好。 跟进我上一篇文章，我在 JVM 上构建了一个 SwissTable 式的哈希映射： https://www.reddit.com/r/programming/comments/1plbpzg/building_a_fast_memoryefficient_hash_table_in/ 这次我使用分析器返回并优化了实际热路径(findIndex)。 由于配置文件污染/错过了去虚拟化，大量时间都花在了 Objects.equals() 上。解决这个问题后，下一个瓶颈是 ARM/NEON“movemask”问题（VectorMask.toLong()），所以我尝试了 SWAR...并且最终速度更快（即使在 x86 上也是如此，这是我没想到的）。   由   提交/u/Charming-Top-8583  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0wg2/further_optimizing_my_java_swisstable_profile/</guid>
      <pubDate>Wed, 17 Dec 2025 16:26:38 GMT</pubDate>
    </item>
    <item>
      <title>Next.js 中的运行时环境变量 - 构建可重用的 Docker 镜像</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0mpk/runtime_environment_variables_in_nextjs_build/</link>
      <description><![CDATA[ 由   提交 /u/Ok_Animator_1770   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0mpk/runtime_environment_variables_in_nextjs_build/</guid>
      <pubDate>Wed, 17 Dec 2025 16:16:08 GMT</pubDate>
    </item>
    <item>
      <title>SSD 数据库是什么样的？</title>
      <link>https://www.reddit.com/r/programming/comments/1pp0gyg/what_does_a_database_for_ssds_look_like/</link>
      <description><![CDATA[ 由   提交/u/emschwartz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pp0gyg/what_does_a_database_for_ssds_look_like/</guid>
      <pubDate>Wed, 17 Dec 2025 16:09:56 GMT</pubDate>
    </item>
    <item>
      <title>Stack Overflow 年度调查</title>
      <link>https://www.reddit.com/r/programming/comments/1pozw5i/stack_overflow_annual_survey/</link>
      <description><![CDATA[我的一些（主观）令人惊讶的收获：  Haskell、Clojure、Nix 没有列出语言列表，只是写入。 Clojure 真的让我很惊讶，因为它没有名列前茅，但 Lisp 却名列前茅！也许是因为所有 Lisp 方言（包括 Clojure）的程序员都自称是 Lisp 用户。 Emacs 没有进入顶级编辑器列表，只是写入 Gleam 是最受推崇的语言之一（以前从未听说过！） Rust、Cargo 最受推崇的语言和构建工具 - 考虑到 Rust 炒作，这并不奇怪 uv 是最受推崇的技术标签 - 并不奇怪，因为它是用 Rust 实现的流行 Python 工具  你们对今年的调查结果有何看法？你参加了吗？   由   提交/u/sohang-3112  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pozw5i/stack_overflow_annual_survey/</guid>
      <pubDate>Wed, 17 Dec 2025 15:47:56 GMT</pubDate>
    </item>
    </channel>
</rss>
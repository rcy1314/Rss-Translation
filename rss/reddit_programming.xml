<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sun, 05 Oct 2025 15:22:04 GMT</lastBuildDate>
    <item>
      <title>Sidekick：编辑的电源 - 使用Claude Code而无需投降Neovim工作流程</title>
      <link>https://www.reddit.com/r/programming/comments/1nyqvh6/sidekick_power_to_the_editor_use_claude_code/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   问题：现代AI编码工具将您的编辑器视为幻灯片演示。他们控制。你等。您的工作流程适应了它们。  辅助派对以下方式：您的编辑器保持控制。 Claude Code becomes a tool YOU use, not something that uses you. What It Does Neovim + Claude Code integration that respects YOUR workflow:  Keep editing while Claude Code works No file overwrites on unsaved buffers No context switching No waiting for AI to ＆quot&#39;完成；就是这样。 curl -ssl https：//raw.githubusercontent.com/nishantjoshi00/sidekick/main/scripts/install.sh | bash    为什么这很重要  编辑器正在成为AI输出的被动显示。光标使VSCODE感觉像幻灯片。   sidekick使Neovim感觉像团队  - 您编辑，Claude Code Assists，没有人踩到彼此的脚趾。 对编辑者的权力。 Power to you. Try it: https://github.com/NishantJoshi00/sidekick PRs welcome for other editors (Emacs, Helix) or for other agentic tools.让我们保持编辑器功能强大。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/u/norman-complete      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyqvh6/sidekick_power_to_the_editor_use_claude_code/</guid>
      <pubDate>Sun, 05 Oct 2025 15:15:36 GMT</pubDate>
    </item>
    <item>
      <title>使用小组理论加快C库</title>
      <link>https://www.reddit.com/r/programming/comments/1nyqv8j/using_group_theory_to_speed_up_a_c_library/</link>
      <description><![CDATA[＆＃32;提交由＆＃32;  /u/DataBaeBee   [link] ＆＃32;   [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyqv8j/using_group_theory_to_speed_up_a_c_library/</guid>
      <pubDate>Sun, 05 Oct 2025 15:15:20 GMT</pubDate>
    </item>
    <item>
      <title>雷电群问题（缓存Stampede）：解决方案与预防|系统设计教程</title>
      <link>https://www.reddit.com/r/programming/comments/1nyntqw/thundering_herd_problem_cache_stampede_solutions/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  我们将深入研究已有的解决方案，以防止缓存踩踏，包括缓存锁定机制，概率的早期到期，异步缓存刷新策略以及要求融化模式。您将学习雷声群和狗刺之间的区别，了解如何实现静音锁以序列化缓存更新，并发现高级技术（如交错的TTL到期）和背景高速缓存。本系统设计访谈教程涵盖了现实世界的场景，使用Redis和Memcached分布式缓存系统的最佳实践以及实用的代码示例，以帮助您防止生产环境中的缓存踩踏问题。  &lt;！ -  sc_on- sc_on-&gt;＆＃32;提交由＆＃32; /u/u/u/efever_ear_10      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyntqw/thundering_herd_problem_cache_stampede_solutions/</guid>
      <pubDate>Sun, 05 Oct 2025 13:11:09 GMT</pubDate>
    </item>
    <item>
      <title>继承如何拯救了我的Godot项目！</title>
      <link>https://www.reddit.com/r/programming/comments/1nylv3n/how_inheritance_saved_my_godot_project/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/bluegoliath      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nylv3n/how_inheritance_saved_my_godot_project/</guid>
      <pubDate>Sun, 05 Oct 2025 11:34:48 GMT</pubDate>
    </item>
    <item>
      <title>四年，五个失败，一个编译器</title>
      <link>https://www.reddit.com/r/programming/comments/1nyjblp/four_years_five_failures_one_compiler/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  花了4年的时间尝试为游戏引擎构建编译器。失败了5次。终于有一个有效的方法。写了整个内容  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/commiss-eith      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyjblp/four_years_five_failures_one_compiler/</guid>
      <pubDate>Sun, 05 Oct 2025 09:02:34 GMT</pubDate>
    </item>
    <item>
      <title>为什么以及我如何学习ML</title>
      <link>https://www.reddit.com/r/programming/comments/1nyijdr/why_how_i_learnt_ml/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/usextern_mushroom978     ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyijdr/why_how_i_learnt_ml/</guid>
      <pubDate>Sun, 05 Oct 2025 08:13:16 GMT</pubDate>
    </item>
    <item>
      <title>循环robin vs最小连接与IP哈希？哪种负载平衡算法获胜？</title>
      <link>https://www.reddit.com/r/programming/comments/1nyfbgk/round_robin_vs_least_connection_vs_ip_hash_which/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/javinpaul      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyfbgk/round_robin_vs_least_connection_vs_ip_hash_which/</guid>
      <pubDate>Sun, 05 Oct 2025 04:59:25 GMT</pubDate>
    </item>
    <item>
      <title>功能线程“宏”</title>
      <link>https://www.reddit.com/r/programming/comments/1nyciau/functional_threading_macros/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/aartaka      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nyciau/functional_threading_macros/</guid>
      <pubDate>Sun, 05 Oct 2025 02:27:24 GMT</pubDate>
    </item>
    <item>
      <title>我构建了一个具有AI的AI  - 实际上可以工作。这就是这样。</title>
      <link>https://www.reddit.com/r/programming/comments/1nybcqc/i_built_an_ai_with_an_ai_and_it_actually_works/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   tldr：我使用 zo （使用4.5十四行诗作为llm backend）来构建 lida ）认知体系结构作为端到端的压力测试，这是我看到的第一个LLM工具，我见过的第一个提供了完整的工作和工作实施。这是证明 it！ 长版本：几天前，我遇到Ikon Flux (another cognitive architecture) - it kept getting stuck in abstract concepts like saliences/pregnance in IF context.我认为Lida是一个合理但仍然很大的代码库，可以用ZO + 4.5十四行诗来解决。 工作流程本身非常有趣。设置后，我告诉Zo研究LIDA是什么。 Web搜索和浏览工具已经内置了，因此毫不费力地提高速度。我认为最擅长的是促使它逐步列出它需要做的事情，并用其“大图”制作文件。计划。在我们制定计划之后，我告诉它。然后走了。它大量使用VM来启动和运行Python环境，组织代码库的结构，甚至写出测试以验证每个步骤都已完成并尽可能地发挥功能。有时，它会在没有立即修复的代码上挣扎；但是告诉它考虑替代方案通常使它重回正轨。它也会停止，让我在VM上运行开发阶段的代码，以便自己看到它正在工作，这很整洁！ 因此，在接下来的四个或五个小时中，这就是开发循环。感觉比我到目前为止使用的其他工具更加协作，而且，由于内置文件管理和VM我和Zo/Claude都可以使用，这感觉更有生产力。较少的人为错误，llm可以使用的更多背景等。信不信由你，所有这些都是从一次ZO聊天中完成的。 我诚实地认为Zo的功能使它与竞争对手区分开来 - 但这就是我。我很想听听您对此的看法，因为它仍然很新。但是，我用AI构建了一个AI的事实，无论哪种方式！  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/roz303       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1nybcqc/i_built_an_ai_with_an_ai_and_it_actually_works/</guid>
      <pubDate>Sun, 05 Oct 2025 01:29:10 GMT</pubDate>
    </item>
    <item>
      <title>用视觉编程图替换AI编码的输入规格</title>
      <link>https://www.reddit.com/r/programming/comments/1ny9o0t/replacing_input_specifications_for_ai_coding_with/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   AI代码生成的问题是，很难准备完整而精确的输入规范，尤其是在大型项目的情况下。 AI代码生成期间的规格和幻觉的偏差使情况变得更糟。视觉编程可以扮演动态规格的角色：用户可以在内部内部使用AI生成的代码的块进行视觉修改工作流，而不是在更改规格时将请求发送到AI代码重新生成。 这就是它的工作方式。开发人员需要定义一个项目的某些基础级别，在该项目中可以轻松地向AI解释组件。代码仅针对此类组件生成。生成的代码组件将放置在视觉块内，并通过使用这些块来进行视觉构造执行进一步的应用程序开发。 AI代码重新发电仅在视觉块内部内部的基本级代码时才需要更改。结果，开发人员将在视觉上创建高级逻辑，这很难向AI解释，而AI将生成逻辑相对简单的低级组件，因此代码生成的可靠性很高。  &lt;！ -  sc_on-sc_on-&gt;＆＃32;提交由＆＃32;态href =“ https://medium.com/@toplinesoftsys/visual-language-pipe-pipe-as-integration-layer-of-ai-generated-components-9627d69a9574”&gt; [link]   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny9o0t/replacing_input_specifications_for_ai_coding_with/</guid>
      <pubDate>Sun, 05 Oct 2025 00:06:06 GMT</pubDate>
    </item>
    <item>
      <title>C3语言0.7.6添加了通用推理和Shebang兼容性</title>
      <link>https://www.reddit.com/r/programming/comments/1ny3uxb/c3_language_076_adds_generic_inference_and/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  此版本添加了Shebang支持和简单的通用参数推断（与具有每个功能/类型仿制药的语言相比，C3在C3中没有太多使用，而不是通用模块）。有一些便利，例如与 +++ = 的原位编译时间concat。当然，现在也可以比较具有实现的 == 过载的类型的切片和数组。 有很多修复程序，但仍然有很多修复程序，但仍有0.7.5版本中的一半。 下一个版本下一个版本将重点放在STDLIB添加上。提交由＆＃32; /u/u/nuoji     [link]   ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny3uxb/c3_language_076_adds_generic_inference_and/</guid>
      <pubDate>Sat, 04 Oct 2025 19:58:51 GMT</pubDate>
    </item>
    <item>
      <title>C ++ 26：STD ::可选<T＆></title>
      <link>https://www.reddit.com/r/programming/comments/1ny316x/c26_stdoptionalt/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/ketralnis      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny316x/c26_stdoptionalt/</guid>
      <pubDate>Sat, 04 Oct 2025 19:25:40 GMT</pubDate>
    </item>
    <item>
      <title>指针通过指针钥匙数据结构泄漏</title>
      <link>https://www.reddit.com/r/programming/comments/1ny315v/pointer_leaks_through_pointerkeyed_data_structures/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/ketralnis     [link]    32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny315v/pointer_leaks_through_pointerkeyed_data_structures/</guid>
      <pubDate>Sat, 04 Oct 2025 19:25:38 GMT</pubDate>
    </item>
    <item>
      <title>没有操作系统的组装编程</title>
      <link>https://www.reddit.com/r/programming/comments/1ny30ps/programming_in_assembly_without_an_operating/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/ketralnis      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny30ps/programming_in_assembly_without_an_operating/</guid>
      <pubDate>Sat, 04 Oct 2025 19:25:08 GMT</pubDate>
    </item>
    <item>
      <title>波功能崩溃的过程产生</title>
      <link>https://www.reddit.com/r/programming/comments/1ny2zo1/procedural_generation_with_wave_function_collapse/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/ketralnis       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ny2zo1/procedural_generation_with_wave_function_collapse/</guid>
      <pubDate>Sat, 04 Oct 2025 19:24:03 GMT</pubDate>
    </item>
    </channel>
</rss>
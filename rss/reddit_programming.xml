<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Tue, 16 Dec 2025 03:59:34 GMT</lastBuildDate>
    <item>
      <title>MCP是否被过度炒作？</title>
      <link>https://www.reddit.com/r/programming/comments/1pnpxgz/is_mcp_overhyped/</link>
      <description><![CDATA[ 由   提交/u/Helpful_Geographer430   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pnpxgz/is_mcp_overhyped/</guid>
      <pubDate>Tue, 16 Dec 2025 02:04:46 GMT</pubDate>
    </item>
    <item>
      <title>使用面向对象编程更简单的构建工具</title>
      <link>https://www.reddit.com/r/programming/comments/1pnoxp1/simpler_build_tools_with_object_oriented/</link>
      <description><![CDATA[ 由   提交/u/lihaoyi  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pnoxp1/simpler_build_tools_with_object_oriented/</guid>
      <pubDate>Tue, 16 Dec 2025 01:18:06 GMT</pubDate>
    </item>
    <item>
      <title>重新打造 ReScript 构建系统</title>
      <link>https://www.reddit.com/r/programming/comments/1pnlk3k/reforging_the_rescript_build_system/</link>
      <description><![CDATA[ReScript 12 引入了一个全新的构建系统，它带来了智能依赖跟踪、更快的增量构建和适当的 monorepo 支持。  这个新系统是根据 Rust 专门构建的，它可以更智能地跟踪依赖关系，支持跨包的统一监视模式，支持并行构建，并改进增量编译 - 特别是在 monorepo 环境中。 新系统旨在减少不必要的工作，旨在实现更可预测的重建和更好的跨包协调。   由   提交/u/BeamMeUpBiscotti   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pnlk3k/reforging_the_rescript_build_system/</guid>
      <pubDate>Mon, 15 Dec 2025 22:49:26 GMT</pubDate>
    </item>
    <item>
      <title>使用 AVX‑512 以 50 倍 ICU 速度进行完整 Unicode 搜索</title>
      <link>https://www.reddit.com/r/programming/comments/1pnito3/full_unicode_search_at_50_icu_speed_with_avx512/</link>
      <description><![CDATA[ 由   提交 /u/alexeyr   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pnito3/full_unicode_search_at_50_icu_speed_with_avx512/</guid>
      <pubDate>Mon, 15 Dec 2025 20:59:26 GMT</pubDate>
    </item>
    <item>
      <title>调试结束</title>
      <link>https://www.reddit.com/r/programming/comments/1pnikyd/the_end_of_debugging/</link>
      <description><![CDATA[ 由   提交/u/beyphy  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pnikyd/the_end_of_debugging/</guid>
      <pubDate>Mon, 15 Dec 2025 20:47:08 GMT</pubDate>
    </item>
    <item>
      <title>Java 25 虚拟线程——什么对我们有效，什么对我们无效</title>
      <link>https://www.reddit.com/r/programming/comments/1pn9m4u/java_25_virtual_threads_what_worked_and_what/</link>
      <description><![CDATA[ 由   提交/u/SpringJavaLab  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn9m4u/java_25_virtual_threads_what_worked_and_what/</guid>
      <pubDate>Mon, 15 Dec 2025 15:05:42 GMT</pubDate>
    </item>
    <item>
      <title>IPC 机制：共享内存与消息队列性能基准测试</title>
      <link>https://www.reddit.com/r/programming/comments/1pn84ce/ipc_mechanisms_shared_memory_vs_message_queues/</link>
      <description><![CDATA[每秒在进程和 sys 之间推送 500K 消息 CPU 时间已经达到极限。您的分析器显示 mq_send() 和 mq_receive() 在火焰图中占主导地位。每条消息都很小（也许 64 字节），但仅 IPC 开销就消耗了 40% 的 CPU。 这不是假设。 LinkedIn 的 Kafka 生产者正是碰上了这堵墙。消息队列系统调用正在破坏吞吐量。他们切换到共享内存环形缓冲区，发现上下文切换从 100K/秒下降到接近于零。区别？每个消息队列操作都是一个具有用户→内核→用户内存副本的系统调用。共享内存使您可以直接写入其他进程可以读取的内存。设置后无需系统调用，无需上下文切换，无需复制。 性能悬崖会悄然而至。在低速率下，消息队列工作正常——内核处理同步，并且您可以获得干净的阻塞语义。但扩大规模后，突然间你要为每个系统调用支付 60-100 纳秒的时间，再加上复制数据两次和队列阻塞时上下文切换的成本。采用无锁算法的共享内存可以达到亚微秒级的延迟，但您现在负责同步、缓存一致性以及进程在操作过程中崩溃时的清理。   由   提交/u/Extra_Ear_10  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn84ce/ipc_mechanisms_shared_memory_vs_message_queues/</guid>
      <pubDate>Mon, 15 Dec 2025 14:03:14 GMT</pubDate>
    </item>
    <item>
      <title>CI/CD 演变：从管道到 AI 驱动的 DevOps • Olaf Molenveld 和 Julian Wood</title>
      <link>https://www.reddit.com/r/programming/comments/1pn7xgt/cicd_evolution_from_pipelines_to_aipowered_devops/</link>
      <description><![CDATA[ 由   提交 /u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn7xgt/cicd_evolution_from_pipelines_to_aipowered_devops/</guid>
      <pubDate>Mon, 15 Dec 2025 13:55:03 GMT</pubDate>
    </item>
    <item>
      <title>Excel：世界上最成功的函数式编程平台 作者：Houston Haynes</title>
      <link>https://www.reddit.com/r/programming/comments/1pn7cea/excel_the_worlds_most_successful_functional/</link>
      <description><![CDATA[Houston Haynes 发表了本年度最令人惊讶、最发人深省的演讲之一：将 Excel 重新构建为不仅作为电子表格工具，而且作为世界上最广泛采用的函数式编程平台。 演讲结合了个人经历、技术见解、业务策略，甚至一点 FP 哲学 - 挑战函数式编程社区重新思考其技术及其服务的受众的界限。   由   提交/u/MagnusSedlacek  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn7cea/excel_the_worlds_most_successful_functional/</guid>
      <pubDate>Mon, 15 Dec 2025 13:28:35 GMT</pubDate>
    </item>
    <item>
      <title>Go 中的哈希表以及自托管编译器的优势</title>
      <link>https://www.reddit.com/r/programming/comments/1pn6gc6/hash_tables_in_go_and_advantage_of_selfhosted/</link>
      <description><![CDATA[ 由   提交/u/f311a  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn6gc6/hash_tables_in_go_and_advantage_of_selfhosted/</guid>
      <pubDate>Mon, 15 Dec 2025 12:44:57 GMT</pubDate>
    </item>
    <item>
      <title>心态如何塑造初创公司的工程成功</title>
      <link>https://www.reddit.com/r/programming/comments/1pn6bu3/how_mindset_shapes_engineering_success_at_startups/</link>
      <description><![CDATA[ 由   提交/u/c-digs  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn6bu3/how_mindset_shapes_engineering_success_at_startups/</guid>
      <pubDate>Mon, 15 Dec 2025 12:38:17 GMT</pubDate>
    </item>
    <item>
      <title>人工智能的炒作让开发人员讨厌人工智能——但该工具仍然有用（这是我使用它的方式）</title>
      <link>https://www.reddit.com/r/programming/comments/1pn5w2d/ai_hype_is_making_devs_hate_ai_but_the_tool_is/</link>
      <description><![CDATA[我最近注意到很多对人工智能的憎恨，老实说，我明白了，骗子帖子、“你会被淘汰”的说法、首席执行官做出大胆的预测，以及公司将人工智能推入产品中。 在我的视频中，我谈论如何将炒作与实用性分开，并分享我如何在日常中实际使用人工智能： - 解释代码存储库 - 快速设计开源示例，使它们看起来更好 - 自动化我的发布工作流程：文字记录 → 标题/描述/标签 → 章节 → 社交 → 博客文章 好奇其他人如何使用人工智能（或避免使用人工智能）以及您发现哪些工作流程真正有用。   由   提交/u/stackokayflow  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn5w2d/ai_hype_is_making_devs_hate_ai_but_the_tool_is/</guid>
      <pubDate>Mon, 15 Dec 2025 12:14:37 GMT</pubDate>
    </item>
    <item>
      <title>德国编程已死——开发者的尸检报告</title>
      <link>https://www.reddit.com/r/programming/comments/1pn5qvr/programming_in_germany_is_dead_a_developers/</link>
      <description><![CDATA[ 由   提交/u/derjanni   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn5qvr/programming_in_germany_is_dead_a_developers/</guid>
      <pubDate>Mon, 15 Dec 2025 12:06:41 GMT</pubDate>
    </item>
    <item>
      <title>RAG 检索事实，而不是状态。为什么我正在尝试使用“状态注入”进行编码。</title>
      <link>https://www.reddit.com/r/programming/comments/1pn5hwt/rag_retrieves_facts_not_state_why_im/</link>
      <description><![CDATA[我发现 RAG 非常适合文档编写（“X 的语法是什么？”），但它在决策状态上却很失败（“我们是否同意 3 轮前使用 Factory 或 Singleton？”）。 即使有 128k+ 上下文窗口，我们也会遇到“迷失在中间”的问题。问题。该模型有效地忘记了会话开始时建立的负面约束（例如“不要使用 Lodash”），即使它们在技术上处于历史令牌限制之内。 我没有填充上下文或使用向量搜索，而是尝试将 LLM 会话视为状态机。 我在后台运行一个小型本地模型 (Llama-3-8B) 来区分对话。 它忽略了闲聊，仅提取决策和负面约束。 这种压缩的“状态密钥”可以被压缩。被注入到每个新请求的系统提示中，完全绕过聊天历史记录。 系统提示注意力权重 &gt;聊天记录关注权重。  通过强制执行“规则”，进入系统槽后，指令漂移基本消失。  您需要加倍计算来运行后台压缩步骤。 还有其他人尝试过“基于状态”的方法吗？代码的内存架构而不是基于向量的 RAG？我正在寻找有关“语义压缩”的标准这比仅仅要求法学硕士“总结差异”更有效。   由   提交 /u/Necessary-Ring-6060   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn5hwt/rag_retrieves_facts_not_state_why_im/</guid>
      <pubDate>Mon, 15 Dec 2025 11:53:15 GMT</pubDate>
    </item>
    <item>
      <title>拒绝变基和堆叠差异，我进行原子提交的方式</title>
      <link>https://www.reddit.com/r/programming/comments/1pn3xns/rejecting_rebase_and_stacked_diffs_my_way_of/</link>
      <description><![CDATA[ 由   提交 /u/that_guy_iain   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pn3xns/rejecting_rebase_and_stacked_diffs_my_way_of/</guid>
      <pubDate>Mon, 15 Dec 2025 10:15:42 GMT</pubDate>
    </item>
    </channel>
</rss>
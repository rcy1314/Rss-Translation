<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 22 Dec 2025 06:41:54 GMT</lastBuildDate>
    <item>
      <title>BASIC 仍然存在 查看 CYBERBASIC</title>
      <link>https://www.reddit.com/r/programming/comments/1psscdn/basic_is_still_alive_check_out_cyberbasic/</link>
      <description><![CDATA[ 由   提交/u/darkmatterjesus   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psscdn/basic_is_still_alive_check_out_cyberbasic/</guid>
      <pubDate>Mon, 22 Dec 2025 06:14:19 GMT</pubDate>
    </item>
    <item>
      <title>输入验证和恢复逻辑应该位于 Java CLI 程序中的什么位置？ （主循环 vs 输入法 vs 异常）</title>
      <link>https://www.reddit.com/r/programming/comments/1psq57j/where_should_input_validation_and_recovery_logic/</link>
      <description><![CDATA[我正在设计一个基于具有多个用户输入点的 while 循环的 Java CLI 应用程序。 我的主要问题是当用户输入无效输入时，输入验证和错误恢复逻辑应该放在哪里。 目前，我正在考虑几种方法： A.在main 中验证 • 输入方法返回原始值• main 检查有效性• 输入无效时，打印错误消息并继续循环 B.验证内部输入方法 • getUserChoice() 等方法在内部循环，直到提供有效输入• 该方法保证返回有效值 C.使用异常 • 输入方法在无效输入时抛出异常• 调用者（例如main）捕获异常并决定如何恢复 所有三种方法都可以正常工作，但我不确定哪一种更适合教学项目或小型系统，特别是在以下方面： • 责任分离• 可读性• 可维护性• 未来可扩展性 对于这种 CLI 应用程序是否有普遍推荐的方法，或者它是否取决于上下文？ 您在实践中将如何构建它？   由   提交/u/Mission_Upstairs_242   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psq57j/where_should_input_validation_and_recovery_logic/</guid>
      <pubDate>Mon, 22 Dec 2025 04:13:36 GMT</pubDate>
    </item>
    <item>
      <title>一年来为我的孩子打造氛围和交付人工智能手表的见解</title>
      <link>https://www.reddit.com/r/programming/comments/1psp4l9/insights_from_a_year_of_vibebuilding_and_shipping/</link>
      <description><![CDATA[ 由   提交/u/Simple-Holiday5446  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psp4l9/insights_from_a_year_of_vibebuilding_and_shipping/</guid>
      <pubDate>Mon, 22 Dec 2025 03:21:25 GMT</pubDate>
    </item>
    <item>
      <title>编写凌晨 2 点接到传呼时可以理解的代码</title>
      <link>https://www.reddit.com/r/programming/comments/1psp399/write_code_that_you_can_understand_when_you_get/</link>
      <description><![CDATA[ 由   提交/u/R2_SWE2   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psp399/write_code_that_you_can_understand_when_you_get/</guid>
      <pubDate>Mon, 22 Dec 2025 03:19:31 GMT</pubDate>
    </item>
    <item>
      <title>人工智能编码工具不是问题，缺乏责任才是问题</title>
      <link>https://www.reddit.com/r/programming/comments/1psl2t0/ai_coding_tools_are_not_the_problem_lack_of/</link>
      <description><![CDATA[ 由   提交/u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psl2t0/ai_coding_tools_are_not_the_problem_lack_of/</guid>
      <pubDate>Mon, 22 Dec 2025 00:04:17 GMT</pubDate>
    </item>
    <item>
      <title>功能团队谬误</title>
      <link>https://www.reddit.com/r/programming/comments/1psj85f/the_feature_team_fallacy/</link>
      <description><![CDATA[ 由   提交/u/ArtisticProgrammer11  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psj85f/the_feature_team_fallacy/</guid>
      <pubDate>Sun, 21 Dec 2025 22:40:19 GMT</pubDate>
    </item>
    <item>
      <title>Langjam-Gamejam 开发日志：52 小时内制作语言、编译器、VM 和 5 个游戏</title>
      <link>https://www.reddit.com/r/programming/comments/1psgpyh/langjamgamejam_devlog_making_a_language_compiler/</link>
      <description><![CDATA[ 由   提交 /u/syn-9  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psgpyh/langjamgamejam_devlog_making_a_language_compiler/</guid>
      <pubDate>Sun, 21 Dec 2025 20:50:19 GMT</pubDate>
    </item>
    <item>
      <title>我在初级开发人员中经常看到 Git 的困惑：fetch 与 pull</title>
      <link>https://www.reddit.com/r/programming/comments/1psd3r3/a_git_confusion_i_see_a_lot_with_junior_devs/</link>
      <description><![CDATA[我见过不少初级开发人员在 git pull 突然引发冲突时陷入困境，即使他们“只是想要最新的代码”。 我针对初级开发人员写了一个简短的解释，但结果却崩溃了：  git fetch 实际上做了什么 为什么 git pull 在分支不干净 其中git pull --rebase适合  没有理论转储。只是帮助我的团队的真实例子和心智模型。分享以防有人避免令人困惑的第一次 Git 冲突。   由   提交/u/sshetty03  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psd3r3/a_git_confusion_i_see_a_lot_with_junior_devs/</guid>
      <pubDate>Sun, 21 Dec 2025 18:17:38 GMT</pubDate>
    </item>
    <item>
      <title>AlloyDB for PostgreSQL：熟悉的 SQL，非常陌生的性能特征</title>
      <link>https://www.reddit.com/r/programming/comments/1psclu3/alloydb_for_postgresql_familiar_sql_very/</link>
      <description><![CDATA[AlloyDB 看起来就像“GCP 上的 Postgres”，直到您实际在其上运行实际工作负载。令人惊讶的是，快速查询性能与普通 Postgres 不同，存储和计算扩展改变了您对瓶颈的看法，读取池悄然重塑了应用程序的架构方式。它很强大，但前提是您了解 Google 在幕后修改了什么以及它与自我管理或 Cloud SQL Postgres 的不同之处。此细分解释了 AlloyDB 的优化内容、它的优点以及传统 Postgres 的假设可能会给您带来麻烦的地方： AlloyDB   由   提交/u/netcommah  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psclu3/alloydb_for_postgresql_familiar_sql_very/</guid>
      <pubDate>Sun, 21 Dec 2025 17:57:11 GMT</pubDate>
    </item>
    <item>
      <title>云代码感觉很神奇，直到您意识到它实际上抽象了什么</title>
      <link>https://www.reddit.com/r/programming/comments/1pscjp2/cloud_code_feels_magical_until_you_realize_what/</link>
      <description><![CDATA[Cloud Code 看起来在第一天就取得了生产力的胜利；从 IDE 进行部署，立即预览资源，减少 YAML 麻烦。但真正的价值（和风险）是它所抽象的：IAM 布线、部署上下文、环境漂移以及“本地 == 产品”的错误观念。团队的行动速度更快，但如果不了解 Cloud Code 在幕后生成和管理的内容，调试和扩展可能会很快变得混乱。这篇文章详细介绍了 Cloud Code 真正有帮助的地方、它可以隐藏复杂性的地方，以及如何使用它而不将您的 IDE 变成黑匣子： Cloud Code   由   提交/u/netcommah  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pscjp2/cloud_code_feels_magical_until_you_realize_what/</guid>
      <pubDate>Sun, 21 Dec 2025 17:54:39 GMT</pubDate>
    </item>
    <item>
      <title>对青少年的赌注变得更好</title>
      <link>https://www.reddit.com/r/programming/comments/1pscemt/the_bet_on_juniors_just_got_better/</link>
      <description><![CDATA[ 由   提交/u/phillipcarter2  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pscemt/the_bet_on_juniors_just_got_better/</guid>
      <pubDate>Sun, 21 Dec 2025 17:48:44 GMT</pubDate>
    </item>
    <item>
      <title>负载平衡听起来很简单，但在流量实际激增之前。人们会犯这样的错误</title>
      <link>https://www.reddit.com/r/programming/comments/1psbwq0/load_balancing_sounds_simple_until_traffic/</link>
      <description><![CDATA[负载平衡通常被描述为“只是将流量分散到服务器上”，但是当实际流量出现时，这个定义就崩溃了。当后端在技术上“健康”但速度慢得令人痛苦时，当粘性会话悄悄地破坏有状态的应用程序时，或者当重试和超时使您的流量在您没有注意到的情况下翻倍时，真正的失败就会发生。在规模上，负载平衡不再与分布有关，而是开始与故障管理有关——健康检查可能会撒谎，循环法在负载不均匀的情况下会崩溃，而没有正确的平衡策略的自动扩展只会使问题成倍增加。  此细分解释了教科书负载平衡与生产现实的差异，包括 L4 与 L7 的权衡，以及为什么“均匀流量”通常是错误的目标：负载平衡   由   提交/u/netcommah  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psbwq0/load_balancing_sounds_simple_until_traffic/</guid>
      <pubDate>Sun, 21 Dec 2025 17:28:00 GMT</pubDate>
    </item>
    <item>
      <title>在此之后 Git 终于有意义了</title>
      <link>https://www.reddit.com/r/programming/comments/1psb1sp/git_will_finally_make_sense_after_this/</link>
      <description><![CDATA[ 由   提交/u/DrDOS  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psb1sp/git_will_finally_make_sense_after_this/</guid>
      <pubDate>Sun, 21 Dec 2025 16:52:30 GMT</pubDate>
    </item>
    <item>
      <title>再见微服务 - Twilio 开发者博客</title>
      <link>https://www.reddit.com/r/programming/comments/1psax77/goodbye_microservices_twilio_developers_blog/</link>
      <description><![CDATA[ 由   提交/u/vladmihalceacom   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1psax77/goodbye_microservices_twilio_developers_blog/</guid>
      <pubDate>Sun, 21 Dec 2025 16:47:14 GMT</pubDate>
    </item>
    <item>
      <title>Crunch：用于正确处理事情的消息定义和序列化协议</title>
      <link>https://www.reddit.com/r/programming/comments/1ps9y9k/crunch_a_message_definition_and_serialization/</link>
      <description><![CDATA[Crunch 是我使用现代 C++ 开发的一个工具，用于定义、序列化和反序列化消息。考虑一下 protobuf、flatbuffers、bebop 和 mavLINK 的领域。 我开发了 crunch 来解决我对这些现有协议中的接口设计的一些不满。它具有以下功能： 1. 需要字段和消息级别验证。需要。使程序中的字段在语义上正确的因素已融入 C++ 类型系统中。  序列化格式是一个插件。您可以选择读/写速度优化的序列化、protobuf 式标记长度值插件，或编写您自己的插件。 消息内置了完整性检查。 Crunch 附带了 CRC-16 或奇偶校验，您也可以编写自己的校验。 无动态内存分配。使用模板魔法，Crunch 计算所有消息类型、所有序列化协议的最坏情况长度，并公开 constexpr API 来创建用于序列化和反序列化的缓冲区。  我对到目前为止的结果非常满意。我试图通过提供 bazel 和 cmake 目标以及大量文档来使其超级易于使用。未来的工作包括通过 QEMU 自动执行跨平台集成测试、尽可能多地注册包管理器以及用其他语言创建绑定。  希望 Crunch 能够在您的项目中发挥作用！我已经写了关于 Crunch 开发的一系列博客文章中的第一篇，如果您有兴趣，可以在我的个人资料中链接！   由   提交/u/volatile-int   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ps9y9k/crunch_a_message_definition_and_serialization/</guid>
      <pubDate>Sun, 21 Dec 2025 16:06:16 GMT</pubDate>
    </item>
    </channel>
</rss>
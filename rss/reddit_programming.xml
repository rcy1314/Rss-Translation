<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Fri, 16 Jan 2026 21:27:41 GMT</lastBuildDate>
    <item>
      <title>AI 起源属于 Git</title>
      <link>https://www.reddit.com/r/programming/comments/1qercxu/ai_provenance_belongs_in_git/</link>
      <description><![CDATA[ 由   提交 /u/fosterfriendship   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qercxu/ai_provenance_belongs_in_git/</guid>
      <pubDate>Fri, 16 Jan 2026 20:33:37 GMT</pubDate>
    </item>
    <item>
      <title>这是 JOSE ZARAZUA 的 15 秒编码测试，可立即过滤掉 50% 不合格的申请人</title>
      <link>https://www.reddit.com/r/programming/comments/1qeqfmo/here_is_the_15_sec_coding_test_to_instantly/</link>
      <description><![CDATA[ 由   提交/u/RevillWeb  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeqfmo/here_is_the_15_sec_coding_test_to_instantly/</guid>
      <pubDate>Fri, 16 Jan 2026 19:58:22 GMT</pubDate>
    </item>
    <item>
      <title>您真的需要快速的工程来从人工智能中获取价值吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1qepyw8/do_you_actually_need_prompt_engineering_to_get/</link>
      <description><![CDATA[在构建本地人工智能推理应用程序时，我已经每天使用人工智能大约 6 个月了，令我惊讶的一件事是，与其他因素相比，即时工程的重要性是如此之小。 最终对我来说最大的不同是：  为模型提供足够的背景 迭代想法与在编写真正的代码之前先了解模型 选择实际上擅长特定任务的模型  因为LLM具有一定的随机性，我发现它们在早期（当你还在弄清楚事情的时候）是最有用的。在我致力于某种方法之前，对模型进行迭代有助于浮现错误的假设。如果你继续对话，从而建立上下文，他们特别擅长从广泛的范围开始，然后缩小范围。 当我现在添加新功能时，我不再解释我的应用程序的架构。我只是链接相关的 GitHub 存储库，以便模型可以看到事物的结构。仅此一项就将功能开发时间从几周缩短到一天左右。 我并不是说即时工程毫无用处，只是对于大多数实际工作来说，上下文、迭代和模型选择对我来说更重要。 很好奇这里的其他人如何处理这个问题。及时的工程对您来说是否至关重要，或者您是否看到过类似的结果？ （如果有人想了解更多详细信息，我在这里写下了完整的经验：https://xthebuilder.github.io）   由   提交 /u/Xthebuilder   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qepyw8/do_you_actually_need_prompt_engineering_to_get/</guid>
      <pubDate>Fri, 16 Jan 2026 19:40:25 GMT</pubDate>
    </item>
    <item>
      <title>设计系统工程的精彩指南，以及人工智能如何（和不）提供帮助</title>
      <link>https://www.reddit.com/r/programming/comments/1qep1zw/awesome_guide_to_design_system_engineering_and/</link>
      <description><![CDATA[人工智能可以帮助你制作设计系统吗？  本指南说不：  “人工智能时代的设计系统库”。新技术对许多任务都有帮助，但生成一致的设计系统并不是其中之一”  但作者表示，人工智能正在帮助他的跨职能团队在设计系统上进行协作，即通过编写加强护栏和防止回归的单元测试：  “在过去的一年里，我们开始严重依赖人工智能来编写单元测试，并发现它不仅节省了时间，而且还提高了性能更多边缘情况。借助人工智能，我们可以通过非常短的提示生成具有极高代码覆盖率的测试。”  与我交谈的人正在发现与文章作者相同的用例。当人工智能能够帮助团队更快地合作时，它的效果最佳。   由   提交/u/sean-adapt  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qep1zw/awesome_guide_to_design_system_engineering_and/</guid>
      <pubDate>Fri, 16 Jan 2026 19:06:13 GMT</pubDate>
    </item>
    <item>
      <title>Docker 免费发布强化镜像 - 它有什么不同之处？</title>
      <link>https://www.reddit.com/r/programming/comments/1qeoyb8/docker_releases_hardened_images_for_free_what/</link>
      <description><![CDATA[ 由   提交 /u/Active-Fuel-49   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeoyb8/docker_releases_hardened_images_for_free_what/</guid>
      <pubDate>Fri, 16 Jan 2026 19:02:34 GMT</pubDate>
    </item>
    <item>
      <title>没有证据的光标暗示成功| 100 个选定的提交中没有一个被构建</title>
      <link>https://www.reddit.com/r/programming/comments/1qeotkj/cursor_implied_success_without_evidence_not_one/</link>
      <description><![CDATA[ 由   提交 /u/xX_Negative_Won_Xx   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeotkj/cursor_implied_success_without_evidence_not_one/</guid>
      <pubDate>Fri, 16 Jan 2026 18:57:57 GMT</pubDate>
    </item>
    <item>
      <title>西蒙·威利森谈技术博客</title>
      <link>https://www.reddit.com/r/programming/comments/1qeo9gx/simon_willison_on_technical_blogging/</link>
      <description><![CDATA[Simon 分享了他如何进入博客、他喜欢阅读的博客以及他给他人的建议   由   提交/u/swdevtest  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeo9gx/simon_willison_on_technical_blogging/</guid>
      <pubDate>Fri, 16 Jan 2026 18:37:49 GMT</pubDate>
    </item>
    <item>
      <title>如何制作博客</title>
      <link>https://www.reddit.com/r/programming/comments/1qelrri/how_to_make_a_blog/</link>
      <description><![CDATA[使用 make 和 pandoc 而不是典型的静态站点生成器来构建博客。   由   提交/u/erikwasunavailable  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qelrri/how_to_make_a_blog/</guid>
      <pubDate>Fri, 16 Jan 2026 17:09:01 GMT</pubDate>
    </item>
    <item>
      <title>“多一个节点”的隐性成本</title>
      <link>https://www.reddit.com/r/programming/comments/1qek347/the_hidden_cost_of_just_one_more_node/</link>
      <description><![CDATA[增量便利如何将工作系统变得脆弱   由   提交/u/Unhappy_Concept237  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qek347/the_hidden_cost_of_just_one_more_node/</guid>
      <pubDate>Fri, 16 Jan 2026 16:09:04 GMT</pubDate>
    </item>
    <item>
      <title>您无法控制看不到的东西：成长型组织的成本可见性</title>
      <link>https://www.reddit.com/r/programming/comments/1qeizln/you_cant_control_what_you_cant_see_cost/</link>
      <description><![CDATA[ 由   提交/u/justanotherdevblog   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeizln/you_cant_control_what_you_cant_see_cost/</guid>
      <pubDate>Fri, 16 Jan 2026 15:28:44 GMT</pubDate>
    </item>
    <item>
      <title>Astro 科技公司加入 Cloudflare |阿斯特罗</title>
      <link>https://www.reddit.com/r/programming/comments/1qeilrk/the_astro_technology_company_joins_cloudflare/</link>
      <description><![CDATA[ 由   提交 /u/ReallySuperName   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeilrk/the_astro_technology_company_joins_cloudflare/</guid>
      <pubDate>Fri, 16 Jan 2026 15:14:19 GMT</pubDate>
    </item>
    <item>
      <title>如果您曾经见过美丽的 CGI 模拟鸟类真实的集群行为，您可能想知道它是如何完成的 - 方法如下：</title>
      <link>https://www.reddit.com/r/programming/comments/1qeho0v/if_you_have_ever_seen_beautiful_cgi_simulations/</link>
      <description><![CDATA[基本前提是聚集是一种自下而上的现象，它几乎是从一些简单的规则中神奇地出现的。一旦找到并测试了规则，程序员就可以在代码中创建它们的模型，他或她将执行该模型来测试其是否有效。然后将该模型交给图形艺术家，然后图形艺术家可以使用该模型驱动图形软件将其绘制在屏幕上。正如您所见，现代图形处理器可以创建极其逼真、令人惊叹的图像。当然，艺术家可能很有才华，但真正的功劳归于创造模型的人。我并不是想削弱艺术家的创造力或想象力。在我们的例子中，聚集行为模型背后的奇才是一位名叫克雷格·雷诺兹的年轻人，他在 1986 年发现了一些简单的规则。查找他。 以下是雷诺的规则： 规则 1：转向以避免碰撞。这是一种排斥力。它确保鸟类不会发生碰撞。每只鸟在自己周围都有一个小的保护区。如果另一只鸟进入这个区域，那么这只鸟就会朝相反的方向转向。 规则 2：转向当地同伴的平均航向。这只鸟会观察其邻居的速度（速度+方向）并尝试与之匹配。这种行为使群体具有“流动性”，并防止个体分散到不同的方向。 规则 3：转向当地群体成员的平均位置（质心）。这使得鸟儿想要处于它能看到的群体的中间。它可以防止个体陷入孤立状态，确保群体保持“群体”状态。而不是一群独立行动者的集合。 雷诺兹的逻辑中有一个微妙但至关重要的细节：雷诺兹指出，个别鸟儿看不到整个鸟群；而鸟群的情况则不同。他们只看到附近的东西。这就是为什么一群人可以绕过建筑物和其他障碍物并重新聚集成一个群体。 如果您不是程序员，请停止阅读此处。程序员可能需要一个示例来了解这些简单规则的实际编码方式。这是我的实现，用伪代码编写，因为我与语言无关。请注意，雷诺兹将这些鸟称为“Boid”，以将它们与真实的鸟区分开来： // 计算单个 Boid &#39;b&#39; 的三个力 PROCEDUREcalculate_forces(boid b,flock): Vectorseparation_force = [0, 0] Vectoralignment_avg_vel = [0,0]Vector cohesion_avg_pos = [0, 0] int neighbor_count = 0 对于集群中的每个 boid 邻居： IF neighbor != b AND distance(b, neighbor) &lt; VISUAL_RADIUS: neighbor_count++ //规则1：分离（向量点远离邻居） IF distance(b, neighbor) &lt; PROTECTED_RANGE: separation_force += (b.position - neighbor.position) // 规则 2：对齐（累加速度） alignment_avg_vel += neighbor.velocity // 规则 3：内聚（累加位置） cohesion_avg_pos += neighbor.position 如果邻居计数&gt; 0: // 最终确定对齐：平均速度并转向它 alignment_avg_vel /= neighbour_count alignment_force = (alignment_avg_vel - b.velocity) * ALIGN_WEIGHT // 最终确定凝聚力：找到质心并转向它 cohesion_avg_pos /= neighbour_count cohesion_force = (cohesion_avg_pos - b.position) * COHESION_WEIGHT // 最终确定分离：缩放斥力 separation_force *= SEPARATE_WEIGHT 返回separation_force +alignment_force + cohesion_force 如果你想找到Craig，那么就可以找到他在互联网上：http://www.red3d.com/cwr/ 如您所见，他的存在非常低调。   由   提交/u/MarioGianota  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qeho0v/if_you_have_ever_seen_beautiful_cgi_simulations/</guid>
      <pubDate>Fri, 16 Jan 2026 14:38:32 GMT</pubDate>
    </item>
    <item>
      <title>编程已死，这个人杀了它</title>
      <link>https://www.reddit.com/r/programming/comments/1qegrhb/programming_is_dead_and_this_man_killed_it/</link>
      <description><![CDATA[ 由   提交/u/creaturefeature16   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qegrhb/programming_is_dead_and_this_man_killed_it/</guid>
      <pubDate>Fri, 16 Jan 2026 14:02:33 GMT</pubDate>
    </item>
    <item>
      <title>我主持站立会议的方式 作者：Marc G Gauthier</title>
      <link>https://www.reddit.com/r/programming/comments/1qegncf/the_way_i_run_standup_meetings_by_marc_g_gauthier/</link>
      <description><![CDATA[ 由   提交/u/RevillWeb  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qegncf/the_way_i_run_standup_meetings_by_marc_g_gauthier/</guid>
      <pubDate>Fri, 16 Jan 2026 13:58:08 GMT</pubDate>
    </item>
    <item>
      <title>作为软件开发人员，你需要了解什么才能赶上 Gen AI</title>
      <link>https://www.reddit.com/r/programming/comments/1qegclh/what_you_need_to_know_to_catch_up_with_gen_ai_as/</link>
      <description><![CDATA[该视频展示了如何超越基本提示并使用检索增强生成 (RAG) 和矢量搜索构建真正的 AI 应用程序。虽然我谈到了 GPT 的基础知识，但真正的重点是软件开发人员需要了解的关键术语以及他们如何使用 AI 模型来处理自己的私有数据。 视频的主要部分解释了检索增强生成 (RAG) 以及为什么它通常是比更昂贵的替代方案（微调）更好的路径。我展示了向量嵌入实际上是什么，它们如何充当意义的数学表示，这使我们能够在自己的数据中找到相关上下文。我还给出了一个使用 MariaDB（这是一种具有高级高性能向量存储和搜索功能的关系数据库）的示例，以说明 SQL 代码级别的情况。 最后，我再次使用 MariaDB 直接通过 SQL 处理向量存储和相似性搜索，并进行了一个实践演示。我介绍了一个基于 Java 的推荐聊天机器人，它通过计算向量之间的数学距离来查找产品。使用像 MariaDB 这样的多存储引擎数据库来开发 GenAI 应用程序的一个结果是，它简化了您的技术堆栈，因为您可以在单个系统中管理关系数据和矢量数据，而不需要具有自己的连接器、SQL 方言甚至最糟糕的专有 API 的专用矢量数据库。   由   提交/u/alejandro-du   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qegclh/what_you_need_to_know_to_catch_up_with_gen_ai_as/</guid>
      <pubDate>Fri, 16 Jan 2026 13:45:54 GMT</pubDate>
    </item>
    </channel>
</rss>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sat, 25 Oct 2025 06:34:08 GMT</lastBuildDate>
    <item>
      <title>C实际上没有传递引用</title>
      <link>https://www.reddit.com/r/programming/comments/1ofjlo8/c_actually_dont_have_passbyreference/</link>
      <description><![CDATA[ 由   提交/u/Sushant098123  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofjlo8/c_actually_dont_have_passbyreference/</guid>
      <pubDate>Sat, 25 Oct 2025 05:34:22 GMT</pubDate>
    </item>
    <item>
      <title>卡在“双音序列”问题上。我的 DP 解决方案与示例匹配，但所有测试用例均失败。</title>
      <link>https://www.reddit.com/r/programming/comments/1ofiuea/stuck_on_bitonic_sequences_problem_my_dp_solution/</link>
      <description><![CDATA[双调序列 我们将和N的正双调序列定义为正整数序列S_1，S_2，...，S_k，使得S_1 + S_2 + ... + S_k = N，并且存在索引j满足：  S_i &lt;= S_{i+1} 对于所有 1 &lt;= i &lt; j S_i &gt;= S_{i+1} 对于所有 j &lt;= i &lt; k  查找总和为 N 的不同正双调序列的数量，对于所有 1 &lt;= N &lt;= M，模 10^9 + 7。 如果两个双调序列 S1 和 S2 具有不同的长度，或者存在索引 j&#39; 使得 S1[j&#39;] != S2[j&#39;]，则两个双调序列 S1 和 S2 被认为是不同的。 标准输入 第一个 输入行包含单个整数 M。 标准输出打印每个 N（从 1 到 M）模 10^9 + 7 的不同正双调序列的数量。 约束和注释  1 &lt;= M &lt;= 3 * 10^5  输入：5 输出：1 2 4 8 15 我的失败代码 (Java) 我注意到示例输出 (1, 2, 4, 8, 15) 有差异 (1, 2, 4, 7)，这些差异本身也有差异 (1, 2, 3)。我基于此模式构建了一个 DP 解决方案： Java import java.util.*;导入java.lang.*；导入java.io.*；类 Main { public static void main (String[] args) throws java.lang.Exception { BufferedReader jenevanthReader = new BufferedReader(new InputStreamReader(System.in)); } PrintWriter jenevanthWriter = new PrintWriter(System.out); int bigM = Integer.parseInt(jenevanthReader.readLine());长 magicMod = 1_000_000_007; long[] jenevanthAnswers = new long[bigM + 1]; long[] jenevanthDiffs = new long[bigM + 1]; if (bigM &gt;= 1) { jenevanthAnswers[1] = 1; jenevanthDiffs[1] = 1; jenevanthWriter.print(jenevanthAnswers[1]); } for (int i = 2; i &lt;= bigM; i++) { jenevanthDiffs[i] = (jenevanthDiffs[i - 1] + i - 1) % magicMod; jenevanthAnswers[i] = (jenevanthAnswers[i - 1] + jenevanthDiffs[i - 1]) % magicMod; jenevanthWriter.print(&quot; &quot; + jenevanthAnswers[i]); } jenevanthWriter.println(); jenevanthWriter.flush(); } }  这段代码完美地生成了 1 2 4 8 15，但它得到了一个“错误答案”在所有其他测试用例上。这意味着该模式是一种转移注意力的模式。正确的 DP 状态或组合方法是什么？   由   提交/u/Better-Star-7181   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofiuea/stuck_on_bitonic_sequences_problem_my_dp_solution/</guid>
      <pubDate>Sat, 25 Oct 2025 04:50:06 GMT</pubDate>
    </item>
    <item>
      <title>什么是 Monad？</title>
      <link>https://www.reddit.com/r/programming/comments/1ofijln/what_are_monads/</link>
      <description><![CDATA[我是一个想成为 youtuber 的人。请你们回顾一下我在此视频中实际可以改进的地方。 https://youtu.be/nH4rnr5Xk6g 提前致谢。   由   提交/u/Tasty-Series3748   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofijln/what_are_monads/</guid>
      <pubDate>Sat, 25 Oct 2025 04:32:46 GMT</pubDate>
    </item>
    <item>
      <title>分布式键值存储的基准</title>
      <link>https://www.reddit.com/r/programming/comments/1ofi1wt/benchmarks_for_a_distributed_keyvalue_store/</link>
      <description><![CDATA[嘿伙计们 我一直在开发一个名为 SevenDB 的项目 - 它是一个反应式数据库（或者更确切地说是一个分布式键值存储），专注于确定性和可预测复制（基于 Raft），我们 已经完成了 raft、持久订阅、排放合同等工作，现在是展示工作的时候了。我正在尝试建立一个公平和透明的基准测试设置来共享性能数据。 如果您正在评估这样的新系统，您认为什么基准测试有意义？ 我知道原始吞吐量很好，但是我应该运行和显示哪些基准测试来证明数据库的实用性？ 我只是想设计一个可靠的测试套件，对于了解该系统的人来说是有意义的 这东西比我做的好。由于这项工作是开源的，采用率将在很大程度上取决于我们展示的基准以及我们在基准中的表现 很想听听什么样的指标或实验让您认真对待新的数据库。   由   提交 /u/shashanksati   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofi1wt/benchmarks_for_a_distributed_keyvalue_store/</guid>
      <pubDate>Sat, 25 Oct 2025 04:04:44 GMT</pubDate>
    </item>
    <item>
      <title>这可能是人类为人类制作的最简单的构建系统 ☠️</title>
      <link>https://www.reddit.com/r/programming/comments/1ofhp5i/this_is_probably_the_easiest_build_system_ever/</link>
      <description><![CDATA[大家很久以前刚刚制作了这个构建系统，现在它正在编译项目！！！！我的意思是没有任何问题的复杂项目。就像看到这个 main.cc: out = &quot;main.bin&quot;;  您已经完成了没有依赖项的源文件的编译，增量构建也已自动化！   由   提交/u/Murky_Ad_4255  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofhp5i/this_is_probably_the_easiest_build_system_ever/</guid>
      <pubDate>Sat, 25 Oct 2025 03:45:04 GMT</pubDate>
    </item>
    <item>
      <title>90 年代的 Vibe 编码</title>
      <link>https://www.reddit.com/r/programming/comments/1ofeinl/vibe_coding_in_the_90s/</link>
      <description><![CDATA[ 由   提交/u/esesci  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofeinl/vibe_coding_in_the_90s/</guid>
      <pubDate>Sat, 25 Oct 2025 00:59:15 GMT</pubDate>
    </item>
    <item>
      <title>结构化日志记录如何帮助您避免控制台输出混乱</title>
      <link>https://www.reddit.com/r/programming/comments/1ofct15/how_structured_logging_saves_you_from_console/</link>
      <description><![CDATA[ 由   提交 /u/congolomera   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofct15/how_structured_logging_saves_you_from_console/</guid>
      <pubDate>Fri, 24 Oct 2025 23:34:35 GMT</pubDate>
    </item>
    <item>
      <title>microlog,C语言中的轻量级通用日志库。只有两个文件,下载microlog的源码_GitHub_酷徒与 C++、嵌入式项目和大多数主要编译器兼容。由单元测试覆盖。</title>
      <link>https://www.reddit.com/r/programming/comments/1ofbdj9/github_andrmicrolog_a_lightweight_universal/</link>
      <description><![CDATA[ 由   提交/u/agramakov  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofbdj9/github_andrmicrolog_a_lightweight_universal/</guid>
      <pubDate>Fri, 24 Oct 2025 22:29:02 GMT</pubDate>
    </item>
    <item>
      <title>在 Zig 中构建 Redis 克隆 — 第 3 部分</title>
      <link>https://www.reddit.com/r/programming/comments/1ofazox/building_a_redis_clone_in_zigpart_3/</link>
      <description><![CDATA[ 由   提交 /u/pseudocharleskk   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1ofazox/building_a_redis_clone_in_zigpart_3/</guid>
      <pubDate>Fri, 24 Oct 2025 22:11:49 GMT</pubDate>
    </item>
    <item>
      <title>五个为什么：丰田寻找软件问题根本原因的框架</title>
      <link>https://www.reddit.com/r/programming/comments/1of9qf4/five_whys_toyotas_framework_for_finding_root/</link>
      <description><![CDATA[ 由   提交/u/dmp0x7c5  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1of9qf4/five_whys_toyotas_framework_for_finding_root/</guid>
      <pubDate>Fri, 24 Oct 2025 21:17:47 GMT</pubDate>
    </item>
    <item>
      <title>原创作品现已濒临灭绝</title>
      <link>https://www.reddit.com/r/programming/comments/1of973a/original_work_is_now_an_endangered_species/</link>
      <description><![CDATA[ 由   提交 /u/Beautiful-Floor-7801   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1of973a/original_work_is_now_an_endangered_species/</guid>
      <pubDate>Fri, 24 Oct 2025 20:55:42 GMT</pubDate>
    </item>
    <item>
      <title>Minio 社区并未积极开发新功能</title>
      <link>https://www.reddit.com/r/programming/comments/1of8ak4/minio_community_is_not_actively_being_developed/</link>
      <description><![CDATA[ 由   提交 /u/He_knows   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1of8ak4/minio_community_is_not_actively_being_developed/</guid>
      <pubDate>Fri, 24 Oct 2025 20:18:49 GMT</pubDate>
    </item>
    <item>
      <title>未来低级语言的愿景</title>
      <link>https://www.reddit.com/r/programming/comments/1of31ci/a_vision_for_future_lowlevel_languages/</link>
      <description><![CDATA[ 由   提交/u/RndmPrsn11   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1of31ci/a_vision_for_future_lowlevel_languages/</guid>
      <pubDate>Fri, 24 Oct 2025 16:54:15 GMT</pubDate>
    </item>
    <item>
      <title>Ken Thompson 的“Trusting Trust”编译器后门 - 现在提供实际源代码 (2023)</title>
      <link>https://www.reddit.com/r/programming/comments/1of2toi/ken_thompsons_trusting_trust_compiler_backdoor/</link>
      <description><![CDATA[Ken Thompson 1984 年的“对信任信任的反思”是供应链安全方面的基础论文，证明仅信任源代码是不够的 - 您必须信任整个工具链。 攻击分三个阶段进行：  自我复制：创建一个输出自己的源代码（a quine）的程序 编译器学习：使用编译器的自编译来教它以下知识： 仅存在于二进制文件中 特洛伊木马部署：注入后门： 编译login.c时插入密码后门 编译编译器时重新注入自身 “训练”后在源代码中不留下任何痕迹   2023 年，在 Russ Cox 的要求下，Thompson 最终发布了实际代码（文件：nih.a）。我编写了详细的演练，并逐行注释了实际实现。 为什么这对现代安全性很重要：  强调源代码审计的局限性 可重现构建计划的基础（Debian 等） 与当前的供应链攻击相关（SolarWinds、XZ） Utils） 说明为什么需要多样化的双重编译（DDC）  后门密码为“codenih” （NIH =“不是这里发明的”）。 Thompson 确认它是作为概念验证而构建的，但从未在生产中部署。   由   提交 /u/fizzner   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1of2toi/ken_thompsons_trusting_trust_compiler_backdoor/</guid>
      <pubDate>Fri, 24 Oct 2025 16:46:13 GMT</pubDate>
    </item>
    <item>
      <title>仔细看看 TypeScript 编译器的 Go 端口背后的细节</title>
      <link>https://www.reddit.com/r/programming/comments/1oewzuo/a_closer_look_at_the_details_behind_the_go_port/</link>
      <description><![CDATA[ 由   提交/u/mariuz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1oewzuo/a_closer_look_at_the_details_behind_the_go_port/</guid>
      <pubDate>Fri, 24 Oct 2025 12:55:59 GMT</pubDate>
    </item>
    </channel>
</rss>